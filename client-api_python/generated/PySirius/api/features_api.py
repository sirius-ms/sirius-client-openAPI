# coding: utf-8

"""
    SIRIUS Nightsky API


    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501
import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr
from typing import List, Optional
from typing_extensions import Annotated
from PySirius.models.aligned_feature import AlignedFeature
from PySirius.models.aligned_feature_opt_field import AlignedFeatureOptField
from PySirius.models.aligned_feature_quality_experimental import AlignedFeatureQualityExperimental
from PySirius.models.annotated_ms_ms_data import AnnotatedMsMsData
from PySirius.models.annotated_spectrum import AnnotatedSpectrum
from PySirius.models.canopus_prediction import CanopusPrediction
from PySirius.models.compound_classes import CompoundClasses
from PySirius.models.feature_import import FeatureImport
from PySirius.models.formula_candidate import FormulaCandidate
from PySirius.models.formula_candidate_opt_field import FormulaCandidateOptField
from PySirius.models.fragmentation_tree import FragmentationTree
from PySirius.models.instrument_profile import InstrumentProfile
from PySirius.models.isotope_pattern_annotation import IsotopePatternAnnotation
from PySirius.models.lipid_annotation import LipidAnnotation
from PySirius.models.ms_data import MsData
from PySirius.models.paged_model_aligned_feature import PagedModelAlignedFeature
from PySirius.models.paged_model_formula_candidate import PagedModelFormulaCandidate
from PySirius.models.paged_model_spectral_library_match import PagedModelSpectralLibraryMatch
from PySirius.models.paged_model_structure_candidate_formula import PagedModelStructureCandidateFormula
from PySirius.models.paged_model_structure_candidate_scored import PagedModelStructureCandidateScored
from PySirius.models.quant_measure import QuantMeasure
from PySirius.models.quant_table_experimental import QuantTableExperimental
from PySirius.models.spectral_library_match import SpectralLibraryMatch
from PySirius.models.spectral_library_match_opt_field import SpectralLibraryMatchOptField
from PySirius.models.spectral_library_match_summary import SpectralLibraryMatchSummary
from PySirius.models.structure_candidate_formula import StructureCandidateFormula
from PySirius.models.structure_candidate_opt_field import StructureCandidateOptField
from PySirius.models.structure_candidate_scored import StructureCandidateScored
from PySirius.models.tag import Tag
from PySirius.models.trace_set_experimental import TraceSetExperimental

from PySirius.api_client import ApiClient, RequestSerialized
from PySirius.api_response import ApiResponse
from PySirius.rest import RESTResponseType


class FeaturesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def add_aligned_features(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to import into.")],
        feature_import: Annotated[List[FeatureImport], Field(description="the feature data to be imported")],
        profile: Annotated[Optional[InstrumentProfile], Field(description="profile describing the instrument used to measure the data. Used to merge spectra.")] = None,
        opt_fields: Annotated[Optional[List[AlignedFeatureOptField]], Field(description="set of optional fields to be included. Use 'none' to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[AlignedFeature]:
        """Import (aligned) features into the project.

        Import (aligned) features into the project. Features must not exist in the project.  Otherwise, they will exist twice.

        :param project_id: project-space to import into. (required)
        :type project_id: str
        :param feature_import: the feature data to be imported (required)
        :type feature_import: List[FeatureImport]
        :param profile: profile describing the instrument used to measure the data. Used to merge spectra.
        :type profile: InstrumentProfile
        :param opt_fields: set of optional fields to be included. Use 'none' to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_aligned_features_serialize(
            project_id=project_id,
            feature_import=feature_import,
            profile=profile,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AlignedFeature]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def add_aligned_features_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to import into.")],
        feature_import: Annotated[List[FeatureImport], Field(description="the feature data to be imported")],
        profile: Annotated[Optional[InstrumentProfile], Field(description="profile describing the instrument used to measure the data. Used to merge spectra.")] = None,
        opt_fields: Annotated[Optional[List[AlignedFeatureOptField]], Field(description="set of optional fields to be included. Use 'none' to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[AlignedFeature]]:
        """Import (aligned) features into the project.

        Import (aligned) features into the project. Features must not exist in the project.  Otherwise, they will exist twice.

        :param project_id: project-space to import into. (required)
        :type project_id: str
        :param feature_import: the feature data to be imported (required)
        :type feature_import: List[FeatureImport]
        :param profile: profile describing the instrument used to measure the data. Used to merge spectra.
        :type profile: InstrumentProfile
        :param opt_fields: set of optional fields to be included. Use 'none' to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_aligned_features_serialize(
            project_id=project_id,
            feature_import=feature_import,
            profile=profile,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AlignedFeature]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def add_aligned_features_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to import into.")],
        feature_import: Annotated[List[FeatureImport], Field(description="the feature data to be imported")],
        profile: Annotated[Optional[InstrumentProfile], Field(description="profile describing the instrument used to measure the data. Used to merge spectra.")] = None,
        opt_fields: Annotated[Optional[List[AlignedFeatureOptField]], Field(description="set of optional fields to be included. Use 'none' to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Import (aligned) features into the project.

        Import (aligned) features into the project. Features must not exist in the project.  Otherwise, they will exist twice.

        :param project_id: project-space to import into. (required)
        :type project_id: str
        :param feature_import: the feature data to be imported (required)
        :type feature_import: List[FeatureImport]
        :param profile: profile describing the instrument used to measure the data. Used to merge spectra.
        :type profile: InstrumentProfile
        :param opt_fields: set of optional fields to be included. Use 'none' to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_aligned_features_serialize(
            project_id=project_id,
            feature_import=feature_import,
            profile=profile,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AlignedFeature]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _add_aligned_features_serialize(
        self,
        project_id,
        feature_import,
        profile,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'FeatureImport': '',
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        # process the query parameters
        if profile is not None:
            
            _query_params.append(('profile', profile.value))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if feature_import is not None:
            _body_params = feature_import


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/projects/{projectId}/aligned-features',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def add_de_novo_structure_candidate(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        smiles: Annotated[Optional[StrictStr], Field(description="smiles")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[StructureCandidateFormula]:
        """[EXPERIMENTAL] Add molecular structures (as SMILES) to the list of de novo structures.

        [EXPERIMENTAL] Add molecular structures (as SMILES) to the list of de novo structures. This starts a scoring job to incorporate the structures in the de novo results list.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param smiles: smiles
        :type smiles: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_de_novo_structure_candidate_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            smiles=smiles,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidateFormula]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def add_de_novo_structure_candidate_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        smiles: Annotated[Optional[StrictStr], Field(description="smiles")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[StructureCandidateFormula]]:
        """[EXPERIMENTAL] Add molecular structures (as SMILES) to the list of de novo structures.

        [EXPERIMENTAL] Add molecular structures (as SMILES) to the list of de novo structures. This starts a scoring job to incorporate the structures in the de novo results list.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param smiles: smiles
        :type smiles: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_de_novo_structure_candidate_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            smiles=smiles,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidateFormula]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def add_de_novo_structure_candidate_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        smiles: Annotated[Optional[StrictStr], Field(description="smiles")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """[EXPERIMENTAL] Add molecular structures (as SMILES) to the list of de novo structures.

        [EXPERIMENTAL] Add molecular structures (as SMILES) to the list of de novo structures. This starts a scoring job to incorporate the structures in the de novo results list.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param smiles: smiles
        :type smiles: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_de_novo_structure_candidate_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            smiles=smiles,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidateFormula]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _add_de_novo_structure_candidate_serialize(
        self,
        project_id,
        aligned_feature_id,
        smiles,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        if smiles is not None:
            
            _query_params.append(('smiles', smiles))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/denovo-structures',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def add_tags_to_aligned_feature_experimental(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to add to.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="run to add tags to.")],
        tag: Annotated[List[Tag], Field(description="tags to add.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Tag]:
        """[EXPERIMENTAL] Add tags to a feature (aligned over runs) in the project

        [EXPERIMENTAL] Add tags to a feature (aligned over runs) in the project. Tags with the same name will be overwritten.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to add to. (required)
        :type project_id: str
        :param aligned_feature_id: run to add tags to. (required)
        :type aligned_feature_id: str
        :param tag: tags to add. (required)
        :type tag: List[Tag]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_tags_to_aligned_feature_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            tag=tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Tag]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def add_tags_to_aligned_feature_experimental_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to add to.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="run to add tags to.")],
        tag: Annotated[List[Tag], Field(description="tags to add.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Tag]]:
        """[EXPERIMENTAL] Add tags to a feature (aligned over runs) in the project

        [EXPERIMENTAL] Add tags to a feature (aligned over runs) in the project. Tags with the same name will be overwritten.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to add to. (required)
        :type project_id: str
        :param aligned_feature_id: run to add tags to. (required)
        :type aligned_feature_id: str
        :param tag: tags to add. (required)
        :type tag: List[Tag]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_tags_to_aligned_feature_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            tag=tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Tag]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def add_tags_to_aligned_feature_experimental_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to add to.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="run to add tags to.")],
        tag: Annotated[List[Tag], Field(description="tags to add.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """[EXPERIMENTAL] Add tags to a feature (aligned over runs) in the project

        [EXPERIMENTAL] Add tags to a feature (aligned over runs) in the project. Tags with the same name will be overwritten.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to add to. (required)
        :type project_id: str
        :param aligned_feature_id: run to add tags to. (required)
        :type aligned_feature_id: str
        :param tag: tags to add. (required)
        :type tag: List[Tag]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_tags_to_aligned_feature_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            tag=tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Tag]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _add_tags_to_aligned_feature_experimental_serialize(
        self,
        project_id,
        aligned_feature_id,
        tag,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'Tag': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if tag is not None:
            _body_params = tag


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/projects/{projectId}/aligned-features/tags/{alignedFeatureId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_aligned_feature(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to delete from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="identifier of feature (aligned over runs) to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete feature (aligned over runs) with the given identifier from the specified project-space.

        Delete feature (aligned over runs) with the given identifier from the specified project-space.

        :param project_id: project-space to delete from. (required)
        :type project_id: str
        :param aligned_feature_id: identifier of feature (aligned over runs) to delete. (required)
        :type aligned_feature_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_aligned_feature_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_aligned_feature_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to delete from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="identifier of feature (aligned over runs) to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete feature (aligned over runs) with the given identifier from the specified project-space.

        Delete feature (aligned over runs) with the given identifier from the specified project-space.

        :param project_id: project-space to delete from. (required)
        :type project_id: str
        :param aligned_feature_id: identifier of feature (aligned over runs) to delete. (required)
        :type aligned_feature_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_aligned_feature_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_aligned_feature_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to delete from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="identifier of feature (aligned over runs) to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete feature (aligned over runs) with the given identifier from the specified project-space.

        Delete feature (aligned over runs) with the given identifier from the specified project-space.

        :param project_id: project-space to delete from. (required)
        :type project_id: str
        :param aligned_feature_id: identifier of feature (aligned over runs) to delete. (required)
        :type aligned_feature_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_aligned_feature_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_aligned_feature_serialize(
        self,
        project_id,
        aligned_feature_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_aligned_features(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to delete from.")],
        request_body: List[StrictStr],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete feature (aligned over runs) with the given identifier from the specified project-space.

        Delete feature (aligned over runs) with the given identifier from the specified project-space.

        :param project_id: project-space to delete from. (required)
        :type project_id: str
        :param request_body: (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_aligned_features_serialize(
            project_id=project_id,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_aligned_features_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to delete from.")],
        request_body: List[StrictStr],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete feature (aligned over runs) with the given identifier from the specified project-space.

        Delete feature (aligned over runs) with the given identifier from the specified project-space.

        :param project_id: project-space to delete from. (required)
        :type project_id: str
        :param request_body: (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_aligned_features_serialize(
            project_id=project_id,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_aligned_features_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to delete from.")],
        request_body: List[StrictStr],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete feature (aligned over runs) with the given identifier from the specified project-space.

        Delete feature (aligned over runs) with the given identifier from the specified project-space.

        :param project_id: project-space to delete from. (required)
        :type project_id: str
        :param request_body: (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_aligned_features_serialize(
            project_id=project_id,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_aligned_features_serialize(
        self,
        project_id,
        request_body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'request_body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/projects/{projectId}/aligned-features/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_adduct_network_with_merged_traces_experimental(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="one feature that is considered the main feature of the adduct network")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TraceSetExperimental:
        """[EXPERIMENTAL] Returns the adduct network for a given alignedFeatureId together with all merged traces contained in the network

        [EXPERIMENTAL] Returns the adduct network for a given alignedFeatureId together with all merged traces contained in the network.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: one feature that is considered the main feature of the adduct network (required)
        :type aligned_feature_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_adduct_network_with_merged_traces_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TraceSetExperimental",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_adduct_network_with_merged_traces_experimental_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="one feature that is considered the main feature of the adduct network")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TraceSetExperimental]:
        """[EXPERIMENTAL] Returns the adduct network for a given alignedFeatureId together with all merged traces contained in the network

        [EXPERIMENTAL] Returns the adduct network for a given alignedFeatureId together with all merged traces contained in the network.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: one feature that is considered the main feature of the adduct network (required)
        :type aligned_feature_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_adduct_network_with_merged_traces_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TraceSetExperimental",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_adduct_network_with_merged_traces_experimental_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="one feature that is considered the main feature of the adduct network")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """[EXPERIMENTAL] Returns the adduct network for a given alignedFeatureId together with all merged traces contained in the network

        [EXPERIMENTAL] Returns the adduct network for a given alignedFeatureId together with all merged traces contained in the network.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: one feature that is considered the main feature of the adduct network (required)
        :type aligned_feature_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_adduct_network_with_merged_traces_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TraceSetExperimental",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_adduct_network_with_merged_traces_experimental_serialize(
        self,
        project_id,
        aligned_feature_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/adducts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_aligned_feature(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="identifier of feature (aligned over runs) to access.")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[AlignedFeatureOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AlignedFeature:
        """Get feature (aligned over runs) with the given identifier from the specified project-space.

        Get feature (aligned over runs) with the given identifier from the specified project-space.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: identifier of feature (aligned over runs) to access. (required)
        :type aligned_feature_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_feature_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AlignedFeature",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_aligned_feature_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="identifier of feature (aligned over runs) to access.")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[AlignedFeatureOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AlignedFeature]:
        """Get feature (aligned over runs) with the given identifier from the specified project-space.

        Get feature (aligned over runs) with the given identifier from the specified project-space.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: identifier of feature (aligned over runs) to access. (required)
        :type aligned_feature_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_feature_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AlignedFeature",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_aligned_feature_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="identifier of feature (aligned over runs) to access.")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[AlignedFeatureOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get feature (aligned over runs) with the given identifier from the specified project-space.

        Get feature (aligned over runs) with the given identifier from the specified project-space.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: identifier of feature (aligned over runs) to access. (required)
        :type aligned_feature_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_feature_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AlignedFeature",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_aligned_feature_serialize(
        self,
        project_id,
        aligned_feature_id,
        ms_data_search_prepared,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        if ms_data_search_prepared is not None:
            
            _query_params.append(('msDataSearchPrepared', ms_data_search_prepared))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_aligned_feature_quality_experimental(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="identifier of feature (aligned over runs) to access.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AlignedFeatureQualityExperimental:
        """[EXPERIMENTAL] Returns data quality information for given feature (alignedFeatureId)  

        [EXPERIMENTAL] Returns data quality information for given feature (alignedFeatureId)  <p>  Get data quality information for feature (aligned over runs) with the given identifier from the specified project-space.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: identifier of feature (aligned over runs) to access. (required)
        :type aligned_feature_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_feature_quality_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AlignedFeatureQualityExperimental",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_aligned_feature_quality_experimental_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="identifier of feature (aligned over runs) to access.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AlignedFeatureQualityExperimental]:
        """[EXPERIMENTAL] Returns data quality information for given feature (alignedFeatureId)  

        [EXPERIMENTAL] Returns data quality information for given feature (alignedFeatureId)  <p>  Get data quality information for feature (aligned over runs) with the given identifier from the specified project-space.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: identifier of feature (aligned over runs) to access. (required)
        :type aligned_feature_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_feature_quality_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AlignedFeatureQualityExperimental",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_aligned_feature_quality_experimental_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="identifier of feature (aligned over runs) to access.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """[EXPERIMENTAL] Returns data quality information for given feature (alignedFeatureId)  

        [EXPERIMENTAL] Returns data quality information for given feature (alignedFeatureId)  <p>  Get data quality information for feature (aligned over runs) with the given identifier from the specified project-space.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: identifier of feature (aligned over runs) to access. (required)
        :type aligned_feature_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_feature_quality_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AlignedFeatureQualityExperimental",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_aligned_feature_quality_experimental_serialize(
        self,
        project_id,
        aligned_feature_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/quality-report',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_aligned_features(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[AlignedFeatureOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[AlignedFeature]:
        """Get all available features (aligned over runs) in the given project-space.

        Get all available features (aligned over runs) in the given project-space.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_features_serialize(
            project_id=project_id,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AlignedFeature]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_aligned_features_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[AlignedFeatureOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[AlignedFeature]]:
        """Get all available features (aligned over runs) in the given project-space.

        Get all available features (aligned over runs) in the given project-space.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_features_serialize(
            project_id=project_id,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AlignedFeature]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_aligned_features_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[AlignedFeatureOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get all available features (aligned over runs) in the given project-space.

        Get all available features (aligned over runs) in the given project-space.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_features_serialize(
            project_id=project_id,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AlignedFeature]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_aligned_features_serialize(
        self,
        project_id,
        ms_data_search_prepared,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        # process the query parameters
        if ms_data_search_prepared is not None:
            
            _query_params.append(('msDataSearchPrepared', ms_data_search_prepared))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_aligned_features_by_group_experimental(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to delete from.")],
        group_name: Annotated[StrictStr, Field(description="tag group name.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[AlignedFeatureOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PagedModelAlignedFeature:
        """[EXPERIMENTAL] Get features (aligned over runs) by tag group

        [EXPERIMENTAL] Get features (aligned over runs) by tag group.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to delete from. (required)
        :type project_id: str
        :param group_name: tag group name. (required)
        :type group_name: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_features_by_group_experimental_serialize(
            project_id=project_id,
            group_name=group_name,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelAlignedFeature",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_aligned_features_by_group_experimental_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to delete from.")],
        group_name: Annotated[StrictStr, Field(description="tag group name.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[AlignedFeatureOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PagedModelAlignedFeature]:
        """[EXPERIMENTAL] Get features (aligned over runs) by tag group

        [EXPERIMENTAL] Get features (aligned over runs) by tag group.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to delete from. (required)
        :type project_id: str
        :param group_name: tag group name. (required)
        :type group_name: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_features_by_group_experimental_serialize(
            project_id=project_id,
            group_name=group_name,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelAlignedFeature",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_aligned_features_by_group_experimental_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to delete from.")],
        group_name: Annotated[StrictStr, Field(description="tag group name.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[AlignedFeatureOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """[EXPERIMENTAL] Get features (aligned over runs) by tag group

        [EXPERIMENTAL] Get features (aligned over runs) by tag group.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to delete from. (required)
        :type project_id: str
        :param group_name: tag group name. (required)
        :type group_name: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_features_by_group_experimental_serialize(
            project_id=project_id,
            group_name=group_name,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelAlignedFeature",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_aligned_features_by_group_experimental_serialize(
        self,
        project_id,
        group_name,
        page,
        size,
        sort,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort': 'multi',
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        # process the query parameters
        if group_name is not None:
            
            _query_params.append(('groupName', group_name))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/grouped',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_aligned_features_by_tag_experimental(
        self,
        project_id: Annotated[StrictStr, Field(description="project space to get features (aligned over runs) from.")],
        filter: Annotated[Optional[StrictStr], Field(description="tag filter.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[AlignedFeatureOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PagedModelAlignedFeature:
        """[EXPERIMENTAL] Get features (aligned over runs) by tag

        [EXPERIMENTAL] Get features (aligned over runs) by tag.   <h2>Supported filter syntax</h2>   <p>The filter string must contain one or more clauses. A clause is prefxed  by a field name.  </p>  <p>  Currently the only searchable fields are names of tags (<code>tagName</code>) followed by a clause that is valued for the value type of the tag (See TagDefinition).  Tag name based field need to be prefixed with the namespace <code>tags.</code>.  Possible value types of tags are <strong>bool</strong>, <strong>integer</strong>, <strong>real</strong>, <strong>text</strong>, <strong>date</strong>, or <strong>time</strong> - tag value   <p>The format of the <strong>date</strong> type is <code>yyyy-MM-dd</code> and of the <strong>time</strong> type is <code>HH\\:mm\\:ss</code>.</p>   <p>A clause may be:</p>  <ul>      <li>a <strong>term</strong>: field name followed by a colon and the search term, e.g. <code>tags.MyTagA:sample</code></li>      <li>a <strong>phrase</strong>: field name followed by a colon and the search phrase in doublequotes, e.g. <code>tags.MyTagA:&quot;Some Text&quot;</code></li>      <li>a <strong>regular expression</strong>: field name followed by a colon and the regex in slashes, e.g. <code>tags.MyTagA:/[mb]oat/</code></li>      <li>a <strong>comparison</strong>: field name followed by a comparison operator and a value, e.g. <code>tags.MyTagB&lt;3</code></li>      <li>a <strong>range</strong>: field name followed by a colon and an open (indiced by <code>[ </code> and <code>] </code>) or (semi-)closed range (indiced by <code>{</code> and <code>}</code>), e.g. <code>tags.MyTagB:[* TO 3] </code></li>  </ul>   <p>Clauses may be <strong>grouped</strong> with brackets <code>( </code> and <code>) </code> and / or <strong>joined</strong> with <code>AND</code> or <code>OR </code> (or <code>&amp;&amp; </code> and <code>|| </code>)</p>   <h3>Example</h3>   <p>The syntax allows to build complex filter queries such as:</p>   <p><code>tags.city:&quot;new york&quot; AND tags.ATextTag:/[mb]oat/ AND tags.count:[1 TO *] OR tags.realNumberTag&lt;=3.2 OR tags.MyDateTag:2024-01-01 OR tags.MyDateTag:[2023-10-01 TO 2023-12-24] OR tags.MyDateTag&lt;2022-01-01 OR tags.time:12\\:00\\:00 OR tags.time:[12\\:00\\:00 TO 14\\:00\\:00] OR tags.time&lt;10\\:00\\:00 </code></p>  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project space to get features (aligned over runs) from. (required)
        :type project_id: str
        :param filter: tag filter.
        :type filter: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_features_by_tag_experimental_serialize(
            project_id=project_id,
            filter=filter,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelAlignedFeature",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_aligned_features_by_tag_experimental_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project space to get features (aligned over runs) from.")],
        filter: Annotated[Optional[StrictStr], Field(description="tag filter.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[AlignedFeatureOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PagedModelAlignedFeature]:
        """[EXPERIMENTAL] Get features (aligned over runs) by tag

        [EXPERIMENTAL] Get features (aligned over runs) by tag.   <h2>Supported filter syntax</h2>   <p>The filter string must contain one or more clauses. A clause is prefxed  by a field name.  </p>  <p>  Currently the only searchable fields are names of tags (<code>tagName</code>) followed by a clause that is valued for the value type of the tag (See TagDefinition).  Tag name based field need to be prefixed with the namespace <code>tags.</code>.  Possible value types of tags are <strong>bool</strong>, <strong>integer</strong>, <strong>real</strong>, <strong>text</strong>, <strong>date</strong>, or <strong>time</strong> - tag value   <p>The format of the <strong>date</strong> type is <code>yyyy-MM-dd</code> and of the <strong>time</strong> type is <code>HH\\:mm\\:ss</code>.</p>   <p>A clause may be:</p>  <ul>      <li>a <strong>term</strong>: field name followed by a colon and the search term, e.g. <code>tags.MyTagA:sample</code></li>      <li>a <strong>phrase</strong>: field name followed by a colon and the search phrase in doublequotes, e.g. <code>tags.MyTagA:&quot;Some Text&quot;</code></li>      <li>a <strong>regular expression</strong>: field name followed by a colon and the regex in slashes, e.g. <code>tags.MyTagA:/[mb]oat/</code></li>      <li>a <strong>comparison</strong>: field name followed by a comparison operator and a value, e.g. <code>tags.MyTagB&lt;3</code></li>      <li>a <strong>range</strong>: field name followed by a colon and an open (indiced by <code>[ </code> and <code>] </code>) or (semi-)closed range (indiced by <code>{</code> and <code>}</code>), e.g. <code>tags.MyTagB:[* TO 3] </code></li>  </ul>   <p>Clauses may be <strong>grouped</strong> with brackets <code>( </code> and <code>) </code> and / or <strong>joined</strong> with <code>AND</code> or <code>OR </code> (or <code>&amp;&amp; </code> and <code>|| </code>)</p>   <h3>Example</h3>   <p>The syntax allows to build complex filter queries such as:</p>   <p><code>tags.city:&quot;new york&quot; AND tags.ATextTag:/[mb]oat/ AND tags.count:[1 TO *] OR tags.realNumberTag&lt;=3.2 OR tags.MyDateTag:2024-01-01 OR tags.MyDateTag:[2023-10-01 TO 2023-12-24] OR tags.MyDateTag&lt;2022-01-01 OR tags.time:12\\:00\\:00 OR tags.time:[12\\:00\\:00 TO 14\\:00\\:00] OR tags.time&lt;10\\:00\\:00 </code></p>  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project space to get features (aligned over runs) from. (required)
        :type project_id: str
        :param filter: tag filter.
        :type filter: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_features_by_tag_experimental_serialize(
            project_id=project_id,
            filter=filter,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelAlignedFeature",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_aligned_features_by_tag_experimental_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project space to get features (aligned over runs) from.")],
        filter: Annotated[Optional[StrictStr], Field(description="tag filter.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[AlignedFeatureOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """[EXPERIMENTAL] Get features (aligned over runs) by tag

        [EXPERIMENTAL] Get features (aligned over runs) by tag.   <h2>Supported filter syntax</h2>   <p>The filter string must contain one or more clauses. A clause is prefxed  by a field name.  </p>  <p>  Currently the only searchable fields are names of tags (<code>tagName</code>) followed by a clause that is valued for the value type of the tag (See TagDefinition).  Tag name based field need to be prefixed with the namespace <code>tags.</code>.  Possible value types of tags are <strong>bool</strong>, <strong>integer</strong>, <strong>real</strong>, <strong>text</strong>, <strong>date</strong>, or <strong>time</strong> - tag value   <p>The format of the <strong>date</strong> type is <code>yyyy-MM-dd</code> and of the <strong>time</strong> type is <code>HH\\:mm\\:ss</code>.</p>   <p>A clause may be:</p>  <ul>      <li>a <strong>term</strong>: field name followed by a colon and the search term, e.g. <code>tags.MyTagA:sample</code></li>      <li>a <strong>phrase</strong>: field name followed by a colon and the search phrase in doublequotes, e.g. <code>tags.MyTagA:&quot;Some Text&quot;</code></li>      <li>a <strong>regular expression</strong>: field name followed by a colon and the regex in slashes, e.g. <code>tags.MyTagA:/[mb]oat/</code></li>      <li>a <strong>comparison</strong>: field name followed by a comparison operator and a value, e.g. <code>tags.MyTagB&lt;3</code></li>      <li>a <strong>range</strong>: field name followed by a colon and an open (indiced by <code>[ </code> and <code>] </code>) or (semi-)closed range (indiced by <code>{</code> and <code>}</code>), e.g. <code>tags.MyTagB:[* TO 3] </code></li>  </ul>   <p>Clauses may be <strong>grouped</strong> with brackets <code>( </code> and <code>) </code> and / or <strong>joined</strong> with <code>AND</code> or <code>OR </code> (or <code>&amp;&amp; </code> and <code>|| </code>)</p>   <h3>Example</h3>   <p>The syntax allows to build complex filter queries such as:</p>   <p><code>tags.city:&quot;new york&quot; AND tags.ATextTag:/[mb]oat/ AND tags.count:[1 TO *] OR tags.realNumberTag&lt;=3.2 OR tags.MyDateTag:2024-01-01 OR tags.MyDateTag:[2023-10-01 TO 2023-12-24] OR tags.MyDateTag&lt;2022-01-01 OR tags.time:12\\:00\\:00 OR tags.time:[12\\:00\\:00 TO 14\\:00\\:00] OR tags.time&lt;10\\:00\\:00 </code></p>  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project space to get features (aligned over runs) from. (required)
        :type project_id: str
        :param filter: tag filter.
        :type filter: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_features_by_tag_experimental_serialize(
            project_id=project_id,
            filter=filter,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelAlignedFeature",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_aligned_features_by_tag_experimental_serialize(
        self,
        project_id,
        filter,
        page,
        size,
        sort,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort': 'multi',
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        # process the query parameters
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/tagged',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_aligned_features_paged(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[AlignedFeatureOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PagedModelAlignedFeature:
        """Get all available features (aligned over runs) in the given project-space.

        Get all available features (aligned over runs) in the given project-space.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_features_paged_serialize(
            project_id=project_id,
            page=page,
            size=size,
            sort=sort,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelAlignedFeature",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_aligned_features_paged_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[AlignedFeatureOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PagedModelAlignedFeature]:
        """Get all available features (aligned over runs) in the given project-space.

        Get all available features (aligned over runs) in the given project-space.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_features_paged_serialize(
            project_id=project_id,
            page=page,
            size=size,
            sort=sort,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelAlignedFeature",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_aligned_features_paged_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[AlignedFeatureOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get all available features (aligned over runs) in the given project-space.

        Get all available features (aligned over runs) in the given project-space.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_features_paged_serialize(
            project_id=project_id,
            page=page,
            size=size,
            sort=sort,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelAlignedFeature",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_aligned_features_paged_serialize(
        self,
        project_id,
        page,
        size,
        sort,
        ms_data_search_prepared,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort': 'multi',
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if ms_data_search_prepared is not None:
            
            _query_params.append(('msDataSearchPrepared', ms_data_search_prepared))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/page',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_best_matching_compound_classes(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CompoundClasses:
        """Return Best matching compound classes for given formulaId

        Return Best matching compound classes for given formulaId.  <p>  Set of the highest scoring compound classes (CANOPUS) on each hierarchy level of  the ClassyFire and NPC ontology,

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_best_matching_compound_classes_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CompoundClasses",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_best_matching_compound_classes_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CompoundClasses]:
        """Return Best matching compound classes for given formulaId

        Return Best matching compound classes for given formulaId.  <p>  Set of the highest scoring compound classes (CANOPUS) on each hierarchy level of  the ClassyFire and NPC ontology,

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_best_matching_compound_classes_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CompoundClasses",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_best_matching_compound_classes_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return Best matching compound classes for given formulaId

        Return Best matching compound classes for given formulaId.  <p>  Set of the highest scoring compound classes (CANOPUS) on each hierarchy level of  the ClassyFire and NPC ontology,

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_best_matching_compound_classes_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CompoundClasses",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_best_matching_compound_classes_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/best-compound-classes',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_canopus_prediction(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CanopusPrediction:
        """All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,

        All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_canopus_prediction_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CanopusPrediction",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_canopus_prediction_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CanopusPrediction]:
        """All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,

        All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_canopus_prediction_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CanopusPrediction",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_canopus_prediction_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,

        All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_canopus_prediction_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CanopusPrediction",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_canopus_prediction_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/canopus-prediction',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_de_novo_structure_candidates(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        opt_fields: Annotated[Optional[List[StructureCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[StructureCandidateFormula]:
        """List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_de_novo_structure_candidates_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidateFormula]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_de_novo_structure_candidates_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        opt_fields: Annotated[Optional[List[StructureCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[StructureCandidateFormula]]:
        """List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_de_novo_structure_candidates_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidateFormula]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_de_novo_structure_candidates_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        opt_fields: Annotated[Optional[List[StructureCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_de_novo_structure_candidates_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidateFormula]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_de_novo_structure_candidates_serialize(
        self,
        project_id,
        aligned_feature_id,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/denovo-structures',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_de_novo_structure_candidates_by_formula(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        opt_fields: Annotated[Optional[List[StructureCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[StructureCandidateScored]:
        """List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_de_novo_structure_candidates_by_formula_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidateScored]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_de_novo_structure_candidates_by_formula_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        opt_fields: Annotated[Optional[List[StructureCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[StructureCandidateScored]]:
        """List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_de_novo_structure_candidates_by_formula_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidateScored]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_de_novo_structure_candidates_by_formula_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        opt_fields: Annotated[Optional[List[StructureCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_de_novo_structure_candidates_by_formula_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidateScored]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_de_novo_structure_candidates_by_formula_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/denovo-structures',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_de_novo_structure_candidates_by_formula_paged(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[StructureCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PagedModelStructureCandidateScored:
        """Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_de_novo_structure_candidates_by_formula_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelStructureCandidateScored",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_de_novo_structure_candidates_by_formula_paged_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[StructureCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PagedModelStructureCandidateScored]:
        """Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_de_novo_structure_candidates_by_formula_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelStructureCandidateScored",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_de_novo_structure_candidates_by_formula_paged_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[StructureCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_de_novo_structure_candidates_by_formula_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelStructureCandidateScored",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_de_novo_structure_candidates_by_formula_paged_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        page,
        size,
        sort,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort': 'multi',
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/denovo-structures/page',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_de_novo_structure_candidates_paged(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[StructureCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PagedModelStructureCandidateFormula:
        """Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_de_novo_structure_candidates_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelStructureCandidateFormula",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_de_novo_structure_candidates_paged_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[StructureCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PagedModelStructureCandidateFormula]:
        """Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_de_novo_structure_candidates_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelStructureCandidateFormula",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_de_novo_structure_candidates_paged_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[StructureCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_de_novo_structure_candidates_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelStructureCandidateFormula",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_de_novo_structure_candidates_paged_serialize(
        self,
        project_id,
        aligned_feature_id,
        page,
        size,
        sort,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort': 'multi',
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/denovo-structures/page',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_feature_quant_table_experimental(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        type: Annotated[Optional[QuantMeasure], Field(description="quantification type.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> QuantTableExperimental:
        """[EXPERIMENTAL]  Returns the full quantification table for the given feature (alignedFeatureId)

        [EXPERIMENTAL]  Returns the full quantification table for the given feature (alignedFeatureId).  <p>  Returns the full quantification table. The quantification table contains a quantities of the features within all  runs they are contained in.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param type: quantification type.
        :type type: QuantMeasure
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_feature_quant_table_experimental_serialize(
            project_id=project_id,
            type=type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "QuantTableExperimental",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_feature_quant_table_experimental_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        type: Annotated[Optional[QuantMeasure], Field(description="quantification type.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[QuantTableExperimental]:
        """[EXPERIMENTAL]  Returns the full quantification table for the given feature (alignedFeatureId)

        [EXPERIMENTAL]  Returns the full quantification table for the given feature (alignedFeatureId).  <p>  Returns the full quantification table. The quantification table contains a quantities of the features within all  runs they are contained in.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param type: quantification type.
        :type type: QuantMeasure
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_feature_quant_table_experimental_serialize(
            project_id=project_id,
            type=type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "QuantTableExperimental",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_feature_quant_table_experimental_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        type: Annotated[Optional[QuantMeasure], Field(description="quantification type.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """[EXPERIMENTAL]  Returns the full quantification table for the given feature (alignedFeatureId)

        [EXPERIMENTAL]  Returns the full quantification table for the given feature (alignedFeatureId).  <p>  Returns the full quantification table. The quantification table contains a quantities of the features within all  runs they are contained in.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param type: quantification type.
        :type type: QuantMeasure
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_feature_quant_table_experimental_serialize(
            project_id=project_id,
            type=type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "QuantTableExperimental",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_feature_quant_table_experimental_serialize(
        self,
        project_id,
        type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        # process the query parameters
        if type is not None:
            
            _query_params.append(('type', type.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/quant-table',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_fingerprint_prediction(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[float]:
        """Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier (formulaId)  

        Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier (formulaId)  <p>  This fingerprint is used to perform structure database search and predict compound classes.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_prediction_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[float]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_fingerprint_prediction_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[float]]:
        """Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier (formulaId)  

        Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier (formulaId)  <p>  This fingerprint is used to perform structure database search and predict compound classes.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_prediction_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[float]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_fingerprint_prediction_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier (formulaId)  

        Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier (formulaId)  <p>  This fingerprint is used to perform structure database search and predict compound classes.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_prediction_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[float]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_fingerprint_prediction_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/fingerprint',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_formula_annotated_ms_ms_data(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AnnotatedMsMsData:
        """Returns MS/MS Spectrum annotated with fragments and losses for provided formulaId

        Returns MS/MS Spectrum annotated with fragments and losses for provided formulaId.  <p>  Returns MS/MS Spectrum (Merged MS/MS and measured MS/MS) which is annotated with fragments and losses  for the given formula result identifier  These annotations are only available if a fragmentation tree and the structure candidate are available.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_annotated_ms_ms_data_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            ms_data_search_prepared=ms_data_search_prepared,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnnotatedMsMsData",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_formula_annotated_ms_ms_data_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AnnotatedMsMsData]:
        """Returns MS/MS Spectrum annotated with fragments and losses for provided formulaId

        Returns MS/MS Spectrum annotated with fragments and losses for provided formulaId.  <p>  Returns MS/MS Spectrum (Merged MS/MS and measured MS/MS) which is annotated with fragments and losses  for the given formula result identifier  These annotations are only available if a fragmentation tree and the structure candidate are available.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_annotated_ms_ms_data_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            ms_data_search_prepared=ms_data_search_prepared,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnnotatedMsMsData",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_formula_annotated_ms_ms_data_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns MS/MS Spectrum annotated with fragments and losses for provided formulaId

        Returns MS/MS Spectrum annotated with fragments and losses for provided formulaId.  <p>  Returns MS/MS Spectrum (Merged MS/MS and measured MS/MS) which is annotated with fragments and losses  for the given formula result identifier  These annotations are only available if a fragmentation tree and the structure candidate are available.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_annotated_ms_ms_data_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            ms_data_search_prepared=ms_data_search_prepared,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnnotatedMsMsData",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_formula_annotated_ms_ms_data_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        ms_data_search_prepared,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        if ms_data_search_prepared is not None:
            
            _query_params.append(('msDataSearchPrepared', ms_data_search_prepared))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/annotated-msmsdata',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_formula_annotated_spectrum(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        spectrum_index: Annotated[Optional[StrictInt], Field(description="index of the spectrum to be annotated. Merged MS/MS will be used if spectrumIndex < 0 (default)")] = None,
        search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AnnotatedSpectrum:
        """Returns a fragmentation spectrum (e

        Returns a fragmentation spectrum (e.g. Merged MS/MS) which is annotated with fragments and losses for the given formula result identifier  <p>  These annotations are only available if a fragmentation tree is available.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param spectrum_index: index of the spectrum to be annotated. Merged MS/MS will be used if spectrumIndex < 0 (default)
        :type spectrum_index: int
        :param search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.
        :type search_prepared: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_annotated_spectrum_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            spectrum_index=spectrum_index,
            search_prepared=search_prepared,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnnotatedSpectrum",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_formula_annotated_spectrum_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        spectrum_index: Annotated[Optional[StrictInt], Field(description="index of the spectrum to be annotated. Merged MS/MS will be used if spectrumIndex < 0 (default)")] = None,
        search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AnnotatedSpectrum]:
        """Returns a fragmentation spectrum (e

        Returns a fragmentation spectrum (e.g. Merged MS/MS) which is annotated with fragments and losses for the given formula result identifier  <p>  These annotations are only available if a fragmentation tree is available.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param spectrum_index: index of the spectrum to be annotated. Merged MS/MS will be used if spectrumIndex < 0 (default)
        :type spectrum_index: int
        :param search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.
        :type search_prepared: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_annotated_spectrum_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            spectrum_index=spectrum_index,
            search_prepared=search_prepared,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnnotatedSpectrum",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_formula_annotated_spectrum_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        spectrum_index: Annotated[Optional[StrictInt], Field(description="index of the spectrum to be annotated. Merged MS/MS will be used if spectrumIndex < 0 (default)")] = None,
        search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns a fragmentation spectrum (e

        Returns a fragmentation spectrum (e.g. Merged MS/MS) which is annotated with fragments and losses for the given formula result identifier  <p>  These annotations are only available if a fragmentation tree is available.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param spectrum_index: index of the spectrum to be annotated. Merged MS/MS will be used if spectrumIndex < 0 (default)
        :type spectrum_index: int
        :param search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.
        :type search_prepared: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_annotated_spectrum_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            spectrum_index=spectrum_index,
            search_prepared=search_prepared,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnnotatedSpectrum",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_formula_annotated_spectrum_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        spectrum_index,
        search_prepared,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        if spectrum_index is not None:
            
            _query_params.append(('spectrumIndex', spectrum_index))
            
        if search_prepared is not None:
            
            _query_params.append(('searchPrepared', search_prepared))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/annotated-spectrum',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_formula_candidate(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[FormulaCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FormulaCandidate:
        """FormulaResultContainers for the given 'formulaId' with minimal information.

        FormulaResultContainers for the given 'formulaId' with minimal information.  Can be enriched with an optional results overview and formula candidate information.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[FormulaCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_candidate_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FormulaCandidate",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_formula_candidate_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[FormulaCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FormulaCandidate]:
        """FormulaResultContainers for the given 'formulaId' with minimal information.

        FormulaResultContainers for the given 'formulaId' with minimal information.  Can be enriched with an optional results overview and formula candidate information.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[FormulaCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_candidate_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FormulaCandidate",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_formula_candidate_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[FormulaCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """FormulaResultContainers for the given 'formulaId' with minimal information.

        FormulaResultContainers for the given 'formulaId' with minimal information.  Can be enriched with an optional results overview and formula candidate information.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[FormulaCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_candidate_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FormulaCandidate",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_formula_candidate_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        ms_data_search_prepared,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        if ms_data_search_prepared is not None:
            
            _query_params.append(('msDataSearchPrepared', ms_data_search_prepared))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_formula_candidates(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[FormulaCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[FormulaCandidate]:
        """List of FormulaResultContainers available for this feature with minimal information.

        List of FormulaResultContainers available for this feature with minimal information.  Can be enriched with an optional results overview.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[FormulaCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_candidates_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FormulaCandidate]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_formula_candidates_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[FormulaCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[FormulaCandidate]]:
        """List of FormulaResultContainers available for this feature with minimal information.

        List of FormulaResultContainers available for this feature with minimal information.  Can be enriched with an optional results overview.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[FormulaCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_candidates_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FormulaCandidate]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_formula_candidates_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[FormulaCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List of FormulaResultContainers available for this feature with minimal information.

        List of FormulaResultContainers available for this feature with minimal information.  Can be enriched with an optional results overview.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[FormulaCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_candidates_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FormulaCandidate]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_formula_candidates_serialize(
        self,
        project_id,
        aligned_feature_id,
        ms_data_search_prepared,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        if ms_data_search_prepared is not None:
            
            _query_params.append(('msDataSearchPrepared', ms_data_search_prepared))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_formula_candidates_paged(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[FormulaCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PagedModelFormulaCandidate:
        """Page of FormulaResultContainers available for this feature with minimal information.

        Page of FormulaResultContainers available for this feature with minimal information.  Can be enriched with an optional results overview.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[FormulaCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_candidates_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            page=page,
            size=size,
            sort=sort,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelFormulaCandidate",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_formula_candidates_paged_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[FormulaCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PagedModelFormulaCandidate]:
        """Page of FormulaResultContainers available for this feature with minimal information.

        Page of FormulaResultContainers available for this feature with minimal information.  Can be enriched with an optional results overview.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[FormulaCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_candidates_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            page=page,
            size=size,
            sort=sort,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelFormulaCandidate",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_formula_candidates_paged_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[FormulaCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Page of FormulaResultContainers available for this feature with minimal information.

        Page of FormulaResultContainers available for this feature with minimal information.  Can be enriched with an optional results overview.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[FormulaCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_candidates_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            page=page,
            size=size,
            sort=sort,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelFormulaCandidate",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_formula_candidates_paged_serialize(
        self,
        project_id,
        aligned_feature_id,
        page,
        size,
        sort,
        ms_data_search_prepared,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort': 'multi',
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if ms_data_search_prepared is not None:
            
            _query_params.append(('msDataSearchPrepared', ms_data_search_prepared))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/page',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_frag_tree(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FragmentationTree:
        """Returns fragmentation tree (SIRIUS) for the given formula result identifier  

        Returns fragmentation tree (SIRIUS) for the given formula result identifier  <p>  This tree is used to rank formula candidates (treeScore).

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_frag_tree_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FragmentationTree",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_frag_tree_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FragmentationTree]:
        """Returns fragmentation tree (SIRIUS) for the given formula result identifier  

        Returns fragmentation tree (SIRIUS) for the given formula result identifier  <p>  This tree is used to rank formula candidates (treeScore).

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_frag_tree_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FragmentationTree",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_frag_tree_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns fragmentation tree (SIRIUS) for the given formula result identifier  

        Returns fragmentation tree (SIRIUS) for the given formula result identifier  <p>  This tree is used to rank formula candidates (treeScore).

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_frag_tree_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FragmentationTree",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_frag_tree_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/fragtree',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_isotope_pattern_annotation(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IsotopePatternAnnotation:
        """Returns Isotope pattern information for given formulaId  

        Returns Isotope pattern information for given formulaId  <p>  Returns Isotope pattern information (simulated isotope pattern, measured isotope pattern, isotope pattern highlighting)  for the given formula result identifier. This simulated isotope pattern is used to rank formula candidates (treeScore).

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_isotope_pattern_annotation_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IsotopePatternAnnotation",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_isotope_pattern_annotation_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IsotopePatternAnnotation]:
        """Returns Isotope pattern information for given formulaId  

        Returns Isotope pattern information for given formulaId  <p>  Returns Isotope pattern information (simulated isotope pattern, measured isotope pattern, isotope pattern highlighting)  for the given formula result identifier. This simulated isotope pattern is used to rank formula candidates (treeScore).

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_isotope_pattern_annotation_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IsotopePatternAnnotation",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_isotope_pattern_annotation_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns Isotope pattern information for given formulaId  

        Returns Isotope pattern information for given formulaId  <p>  Returns Isotope pattern information (simulated isotope pattern, measured isotope pattern, isotope pattern highlighting)  for the given formula result identifier. This simulated isotope pattern is used to rank formula candidates (treeScore).

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_isotope_pattern_annotation_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IsotopePatternAnnotation",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_isotope_pattern_annotation_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/isotope-pattern',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_lipid_annotation(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> LipidAnnotation:
        """Returns Lipid annotation (ElGordo) for the given formulaId

        Returns Lipid annotation (ElGordo) for the given formulaId.  <p>  ElGordo lipid annotation runs as part of the SIRIUS formula identification step.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_lipid_annotation_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LipidAnnotation",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_lipid_annotation_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[LipidAnnotation]:
        """Returns Lipid annotation (ElGordo) for the given formulaId

        Returns Lipid annotation (ElGordo) for the given formulaId.  <p>  ElGordo lipid annotation runs as part of the SIRIUS formula identification step.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_lipid_annotation_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LipidAnnotation",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_lipid_annotation_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns Lipid annotation (ElGordo) for the given formulaId

        Returns Lipid annotation (ElGordo) for the given formulaId.  <p>  ElGordo lipid annotation runs as part of the SIRIUS formula identification step.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_lipid_annotation_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LipidAnnotation",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_lipid_annotation_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/lipid-annotation',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_ms_data(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the Mass Spec data belongs to.")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MsData:
        """Mass Spec data (input data) for the given 'alignedFeatureId' .

        Mass Spec data (input data) for the given 'alignedFeatureId' .

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the Mass Spec data belongs to. (required)
        :type aligned_feature_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ms_data_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            ms_data_search_prepared=ms_data_search_prepared,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MsData",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_ms_data_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the Mass Spec data belongs to.")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MsData]:
        """Mass Spec data (input data) for the given 'alignedFeatureId' .

        Mass Spec data (input data) for the given 'alignedFeatureId' .

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the Mass Spec data belongs to. (required)
        :type aligned_feature_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ms_data_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            ms_data_search_prepared=ms_data_search_prepared,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MsData",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_ms_data_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the Mass Spec data belongs to.")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Mass Spec data (input data) for the given 'alignedFeatureId' .

        Mass Spec data (input data) for the given 'alignedFeatureId' .

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the Mass Spec data belongs to. (required)
        :type aligned_feature_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ms_data_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            ms_data_search_prepared=ms_data_search_prepared,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MsData",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_ms_data_serialize(
        self,
        project_id,
        aligned_feature_id,
        ms_data_search_prepared,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        if ms_data_search_prepared is not None:
            
            _query_params.append(('msDataSearchPrepared', ms_data_search_prepared))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/ms-data',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_quant_table_row_experimental(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature which quantity should be read out")],
        type: Annotated[Optional[QuantMeasure], Field(description="quantification type. Currently, only APEX_HEIGHT is supported, which is the intensity of the feature at its apex.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> QuantTableExperimental:
        """[EXPERIMENTAL] Returns a single quantification table row for the given feature (alignedFeatureId)

        [EXPERIMENTAL] Returns a single quantification table row for the given feature (alignedFeatureId).  <p>  The quantification table contains a quantity of the feature within all samples it is contained in.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature which quantity should be read out (required)
        :type aligned_feature_id: str
        :param type: quantification type. Currently, only APEX_HEIGHT is supported, which is the intensity of the feature at its apex.
        :type type: QuantMeasure
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_quant_table_row_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            type=type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "QuantTableExperimental",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_quant_table_row_experimental_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature which quantity should be read out")],
        type: Annotated[Optional[QuantMeasure], Field(description="quantification type. Currently, only APEX_HEIGHT is supported, which is the intensity of the feature at its apex.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[QuantTableExperimental]:
        """[EXPERIMENTAL] Returns a single quantification table row for the given feature (alignedFeatureId)

        [EXPERIMENTAL] Returns a single quantification table row for the given feature (alignedFeatureId).  <p>  The quantification table contains a quantity of the feature within all samples it is contained in.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature which quantity should be read out (required)
        :type aligned_feature_id: str
        :param type: quantification type. Currently, only APEX_HEIGHT is supported, which is the intensity of the feature at its apex.
        :type type: QuantMeasure
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_quant_table_row_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            type=type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "QuantTableExperimental",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_quant_table_row_experimental_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature which quantity should be read out")],
        type: Annotated[Optional[QuantMeasure], Field(description="quantification type. Currently, only APEX_HEIGHT is supported, which is the intensity of the feature at its apex.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """[EXPERIMENTAL] Returns a single quantification table row for the given feature (alignedFeatureId)

        [EXPERIMENTAL] Returns a single quantification table row for the given feature (alignedFeatureId).  <p>  The quantification table contains a quantity of the feature within all samples it is contained in.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature which quantity should be read out (required)
        :type aligned_feature_id: str
        :param type: quantification type. Currently, only APEX_HEIGHT is supported, which is the intensity of the feature at its apex.
        :type type: QuantMeasure
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_quant_table_row_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            type=type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "QuantTableExperimental",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_quant_table_row_experimental_serialize(
        self,
        project_id,
        aligned_feature_id,
        type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        if type is not None:
            
            _query_params.append(('type', type.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/quant-table-row',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_spectral_library_match(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        match_id: Annotated[StrictStr, Field(description="id of the library match to be returned.")],
        opt_fields: Optional[List[SpectralLibraryMatchOptField]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SpectralLibraryMatch:
        """Spectral library match for the given 'alignedFeatureId'.

        Spectral library match for the given 'alignedFeatureId'.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param match_id: id of the library match to be returned. (required)
        :type match_id: str
        :param opt_fields:
        :type opt_fields: List[SpectralLibraryMatchOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spectral_library_match_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            match_id=match_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpectralLibraryMatch",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_spectral_library_match_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        match_id: Annotated[StrictStr, Field(description="id of the library match to be returned.")],
        opt_fields: Optional[List[SpectralLibraryMatchOptField]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SpectralLibraryMatch]:
        """Spectral library match for the given 'alignedFeatureId'.

        Spectral library match for the given 'alignedFeatureId'.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param match_id: id of the library match to be returned. (required)
        :type match_id: str
        :param opt_fields:
        :type opt_fields: List[SpectralLibraryMatchOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spectral_library_match_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            match_id=match_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpectralLibraryMatch",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_spectral_library_match_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        match_id: Annotated[StrictStr, Field(description="id of the library match to be returned.")],
        opt_fields: Optional[List[SpectralLibraryMatchOptField]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Spectral library match for the given 'alignedFeatureId'.

        Spectral library match for the given 'alignedFeatureId'.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param match_id: id of the library match to be returned. (required)
        :type match_id: str
        :param opt_fields:
        :type opt_fields: List[SpectralLibraryMatchOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spectral_library_match_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            match_id=match_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpectralLibraryMatch",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_spectral_library_match_serialize(
        self,
        project_id,
        aligned_feature_id,
        match_id,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if match_id is not None:
            _path_params['matchId'] = match_id
        # process the query parameters
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/spectral-library-matches/{matchId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_spectral_library_matches(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        min_shared_peaks: Optional[StrictInt] = None,
        min_similarity: Optional[float] = None,
        inchi_key: Optional[StrictStr] = None,
        opt_fields: Optional[List[SpectralLibraryMatchOptField]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[SpectralLibraryMatch]:
        """List of spectral library matches for the given 'alignedFeatureId'.

        List of spectral library matches for the given 'alignedFeatureId'.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param min_shared_peaks:
        :type min_shared_peaks: int
        :param min_similarity:
        :type min_similarity: float
        :param inchi_key:
        :type inchi_key: str
        :param opt_fields:
        :type opt_fields: List[SpectralLibraryMatchOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spectral_library_matches_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            min_shared_peaks=min_shared_peaks,
            min_similarity=min_similarity,
            inchi_key=inchi_key,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SpectralLibraryMatch]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_spectral_library_matches_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        min_shared_peaks: Optional[StrictInt] = None,
        min_similarity: Optional[float] = None,
        inchi_key: Optional[StrictStr] = None,
        opt_fields: Optional[List[SpectralLibraryMatchOptField]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[SpectralLibraryMatch]]:
        """List of spectral library matches for the given 'alignedFeatureId'.

        List of spectral library matches for the given 'alignedFeatureId'.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param min_shared_peaks:
        :type min_shared_peaks: int
        :param min_similarity:
        :type min_similarity: float
        :param inchi_key:
        :type inchi_key: str
        :param opt_fields:
        :type opt_fields: List[SpectralLibraryMatchOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spectral_library_matches_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            min_shared_peaks=min_shared_peaks,
            min_similarity=min_similarity,
            inchi_key=inchi_key,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SpectralLibraryMatch]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_spectral_library_matches_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        min_shared_peaks: Optional[StrictInt] = None,
        min_similarity: Optional[float] = None,
        inchi_key: Optional[StrictStr] = None,
        opt_fields: Optional[List[SpectralLibraryMatchOptField]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List of spectral library matches for the given 'alignedFeatureId'.

        List of spectral library matches for the given 'alignedFeatureId'.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param min_shared_peaks:
        :type min_shared_peaks: int
        :param min_similarity:
        :type min_similarity: float
        :param inchi_key:
        :type inchi_key: str
        :param opt_fields:
        :type opt_fields: List[SpectralLibraryMatchOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spectral_library_matches_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            min_shared_peaks=min_shared_peaks,
            min_similarity=min_similarity,
            inchi_key=inchi_key,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SpectralLibraryMatch]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_spectral_library_matches_serialize(
        self,
        project_id,
        aligned_feature_id,
        min_shared_peaks,
        min_similarity,
        inchi_key,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        if min_shared_peaks is not None:
            
            _query_params.append(('minSharedPeaks', min_shared_peaks))
            
        if min_similarity is not None:
            
            _query_params.append(('minSimilarity', min_similarity))
            
        if inchi_key is not None:
            
            _query_params.append(('inchiKey', inchi_key))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/spectral-library-matches',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_spectral_library_matches_paged(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        min_shared_peaks: Optional[StrictInt] = None,
        min_similarity: Optional[float] = None,
        inchi_key: Optional[StrictStr] = None,
        opt_fields: Optional[List[SpectralLibraryMatchOptField]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PagedModelSpectralLibraryMatch:
        """Page of spectral library matches for the given 'alignedFeatureId'.

        Page of spectral library matches for the given 'alignedFeatureId'.  If a 'inchiKey' (2D) is provided, returns only matches for the database compound with the given InChI key.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param min_shared_peaks:
        :type min_shared_peaks: int
        :param min_similarity:
        :type min_similarity: float
        :param inchi_key:
        :type inchi_key: str
        :param opt_fields:
        :type opt_fields: List[SpectralLibraryMatchOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spectral_library_matches_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            page=page,
            size=size,
            sort=sort,
            min_shared_peaks=min_shared_peaks,
            min_similarity=min_similarity,
            inchi_key=inchi_key,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelSpectralLibraryMatch",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_spectral_library_matches_paged_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        min_shared_peaks: Optional[StrictInt] = None,
        min_similarity: Optional[float] = None,
        inchi_key: Optional[StrictStr] = None,
        opt_fields: Optional[List[SpectralLibraryMatchOptField]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PagedModelSpectralLibraryMatch]:
        """Page of spectral library matches for the given 'alignedFeatureId'.

        Page of spectral library matches for the given 'alignedFeatureId'.  If a 'inchiKey' (2D) is provided, returns only matches for the database compound with the given InChI key.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param min_shared_peaks:
        :type min_shared_peaks: int
        :param min_similarity:
        :type min_similarity: float
        :param inchi_key:
        :type inchi_key: str
        :param opt_fields:
        :type opt_fields: List[SpectralLibraryMatchOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spectral_library_matches_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            page=page,
            size=size,
            sort=sort,
            min_shared_peaks=min_shared_peaks,
            min_similarity=min_similarity,
            inchi_key=inchi_key,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelSpectralLibraryMatch",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_spectral_library_matches_paged_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        min_shared_peaks: Optional[StrictInt] = None,
        min_similarity: Optional[float] = None,
        inchi_key: Optional[StrictStr] = None,
        opt_fields: Optional[List[SpectralLibraryMatchOptField]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Page of spectral library matches for the given 'alignedFeatureId'.

        Page of spectral library matches for the given 'alignedFeatureId'.  If a 'inchiKey' (2D) is provided, returns only matches for the database compound with the given InChI key.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param min_shared_peaks:
        :type min_shared_peaks: int
        :param min_similarity:
        :type min_similarity: float
        :param inchi_key:
        :type inchi_key: str
        :param opt_fields:
        :type opt_fields: List[SpectralLibraryMatchOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spectral_library_matches_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            page=page,
            size=size,
            sort=sort,
            min_shared_peaks=min_shared_peaks,
            min_similarity=min_similarity,
            inchi_key=inchi_key,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelSpectralLibraryMatch",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_spectral_library_matches_paged_serialize(
        self,
        project_id,
        aligned_feature_id,
        page,
        size,
        sort,
        min_shared_peaks,
        min_similarity,
        inchi_key,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort': 'multi',
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if min_shared_peaks is not None:
            
            _query_params.append(('minSharedPeaks', min_shared_peaks))
            
        if min_similarity is not None:
            
            _query_params.append(('minSimilarity', min_similarity))
            
        if inchi_key is not None:
            
            _query_params.append(('inchiKey', inchi_key))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/spectral-library-matches/page',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_spectral_library_matches_summary(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        min_shared_peaks: Annotated[Optional[StrictInt], Field(description="min threshold of shared peaks.")] = None,
        min_similarity: Annotated[Optional[float], Field(description="min spectral similarity threshold.")] = None,
        inchi_key: Annotated[Optional[StrictStr], Field(description="2D inchi key of the compound in the structure database.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SpectralLibraryMatchSummary:
        """Summarize matched reference spectra for the given 'alignedFeatureId'.

        Summarize matched reference spectra for the given 'alignedFeatureId'.  If a 'inchiKey' (2D) is provided, summarizes only contains matches for the database compound with the given InChI key.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param min_shared_peaks: min threshold of shared peaks.
        :type min_shared_peaks: int
        :param min_similarity: min spectral similarity threshold.
        :type min_similarity: float
        :param inchi_key: 2D inchi key of the compound in the structure database.
        :type inchi_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spectral_library_matches_summary_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            min_shared_peaks=min_shared_peaks,
            min_similarity=min_similarity,
            inchi_key=inchi_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpectralLibraryMatchSummary",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_spectral_library_matches_summary_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        min_shared_peaks: Annotated[Optional[StrictInt], Field(description="min threshold of shared peaks.")] = None,
        min_similarity: Annotated[Optional[float], Field(description="min spectral similarity threshold.")] = None,
        inchi_key: Annotated[Optional[StrictStr], Field(description="2D inchi key of the compound in the structure database.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SpectralLibraryMatchSummary]:
        """Summarize matched reference spectra for the given 'alignedFeatureId'.

        Summarize matched reference spectra for the given 'alignedFeatureId'.  If a 'inchiKey' (2D) is provided, summarizes only contains matches for the database compound with the given InChI key.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param min_shared_peaks: min threshold of shared peaks.
        :type min_shared_peaks: int
        :param min_similarity: min spectral similarity threshold.
        :type min_similarity: float
        :param inchi_key: 2D inchi key of the compound in the structure database.
        :type inchi_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spectral_library_matches_summary_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            min_shared_peaks=min_shared_peaks,
            min_similarity=min_similarity,
            inchi_key=inchi_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpectralLibraryMatchSummary",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_spectral_library_matches_summary_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        min_shared_peaks: Annotated[Optional[StrictInt], Field(description="min threshold of shared peaks.")] = None,
        min_similarity: Annotated[Optional[float], Field(description="min spectral similarity threshold.")] = None,
        inchi_key: Annotated[Optional[StrictStr], Field(description="2D inchi key of the compound in the structure database.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Summarize matched reference spectra for the given 'alignedFeatureId'.

        Summarize matched reference spectra for the given 'alignedFeatureId'.  If a 'inchiKey' (2D) is provided, summarizes only contains matches for the database compound with the given InChI key.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param min_shared_peaks: min threshold of shared peaks.
        :type min_shared_peaks: int
        :param min_similarity: min spectral similarity threshold.
        :type min_similarity: float
        :param inchi_key: 2D inchi key of the compound in the structure database.
        :type inchi_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spectral_library_matches_summary_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            min_shared_peaks=min_shared_peaks,
            min_similarity=min_similarity,
            inchi_key=inchi_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpectralLibraryMatchSummary",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_spectral_library_matches_summary_serialize(
        self,
        project_id,
        aligned_feature_id,
        min_shared_peaks,
        min_similarity,
        inchi_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        if min_shared_peaks is not None:
            
            _query_params.append(('minSharedPeaks', min_shared_peaks))
            
        if min_similarity is not None:
            
            _query_params.append(('minSimilarity', min_similarity))
            
        if inchi_key is not None:
            
            _query_params.append(('inchiKey', inchi_key))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/spectral-library-matches/summary',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_structure_annotated_ms_data_experimental(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        inchi_key: Annotated[StrictStr, Field(description="2d InChIKey of the structure candidate to be used to annotate the spectrum annotation")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AnnotatedMsMsData:
        """[EXPERIMENTAL] Returns MS/MS Data annotated with fragments and losses for given formulaId and inChIKey

        [EXPERIMENTAL] Returns MS/MS Data annotated with fragments and losses for given formulaId and inChIKey.  <p>  Returns MS/MS Data (Merged MS/MS and list of measured MS/MS ) which are annotated with fragments and losses  for the given formula result identifier and structure candidate inChIKey.  These annotations are only available if a fragmentation tree and the structure candidate are available.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param inchi_key: 2d InChIKey of the structure candidate to be used to annotate the spectrum annotation (required)
        :type inchi_key: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_annotated_ms_data_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            inchi_key=inchi_key,
            ms_data_search_prepared=ms_data_search_prepared,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnnotatedMsMsData",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_structure_annotated_ms_data_experimental_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        inchi_key: Annotated[StrictStr, Field(description="2d InChIKey of the structure candidate to be used to annotate the spectrum annotation")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AnnotatedMsMsData]:
        """[EXPERIMENTAL] Returns MS/MS Data annotated with fragments and losses for given formulaId and inChIKey

        [EXPERIMENTAL] Returns MS/MS Data annotated with fragments and losses for given formulaId and inChIKey.  <p>  Returns MS/MS Data (Merged MS/MS and list of measured MS/MS ) which are annotated with fragments and losses  for the given formula result identifier and structure candidate inChIKey.  These annotations are only available if a fragmentation tree and the structure candidate are available.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param inchi_key: 2d InChIKey of the structure candidate to be used to annotate the spectrum annotation (required)
        :type inchi_key: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_annotated_ms_data_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            inchi_key=inchi_key,
            ms_data_search_prepared=ms_data_search_prepared,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnnotatedMsMsData",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_structure_annotated_ms_data_experimental_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        inchi_key: Annotated[StrictStr, Field(description="2d InChIKey of the structure candidate to be used to annotate the spectrum annotation")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """[EXPERIMENTAL] Returns MS/MS Data annotated with fragments and losses for given formulaId and inChIKey

        [EXPERIMENTAL] Returns MS/MS Data annotated with fragments and losses for given formulaId and inChIKey.  <p>  Returns MS/MS Data (Merged MS/MS and list of measured MS/MS ) which are annotated with fragments and losses  for the given formula result identifier and structure candidate inChIKey.  These annotations are only available if a fragmentation tree and the structure candidate are available.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param inchi_key: 2d InChIKey of the structure candidate to be used to annotate the spectrum annotation (required)
        :type inchi_key: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_annotated_ms_data_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            inchi_key=inchi_key,
            ms_data_search_prepared=ms_data_search_prepared,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnnotatedMsMsData",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_structure_annotated_ms_data_experimental_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        inchi_key,
        ms_data_search_prepared,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        if inchi_key is not None:
            _path_params['inchiKey'] = inchi_key
        # process the query parameters
        if ms_data_search_prepared is not None:
            
            _query_params.append(('msDataSearchPrepared', ms_data_search_prepared))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/structures/{inchiKey}/annotated-msmsdata',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_structure_annotated_spectral_library_match_experimental(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        match_id: Annotated[StrictStr, Field(description="id of the library match to be returned.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AnnotatedSpectrum:
        """[EXPERIMENTAL] Spectral library match for the given 'alignedFeatureId' with additional molecular formula and substructure annotations

        [EXPERIMENTAL] Spectral library match for the given 'alignedFeatureId' with additional molecular formula and substructure annotations.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param match_id: id of the library match to be returned. (required)
        :type match_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_annotated_spectral_library_match_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            match_id=match_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnnotatedSpectrum",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_structure_annotated_spectral_library_match_experimental_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        match_id: Annotated[StrictStr, Field(description="id of the library match to be returned.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AnnotatedSpectrum]:
        """[EXPERIMENTAL] Spectral library match for the given 'alignedFeatureId' with additional molecular formula and substructure annotations

        [EXPERIMENTAL] Spectral library match for the given 'alignedFeatureId' with additional molecular formula and substructure annotations.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param match_id: id of the library match to be returned. (required)
        :type match_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_annotated_spectral_library_match_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            match_id=match_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnnotatedSpectrum",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_structure_annotated_spectral_library_match_experimental_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        match_id: Annotated[StrictStr, Field(description="id of the library match to be returned.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """[EXPERIMENTAL] Spectral library match for the given 'alignedFeatureId' with additional molecular formula and substructure annotations

        [EXPERIMENTAL] Spectral library match for the given 'alignedFeatureId' with additional molecular formula and substructure annotations.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param match_id: id of the library match to be returned. (required)
        :type match_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_annotated_spectral_library_match_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            match_id=match_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnnotatedSpectrum",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_structure_annotated_spectral_library_match_experimental_serialize(
        self,
        project_id,
        aligned_feature_id,
        match_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if match_id is not None:
            _path_params['matchId'] = match_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/spectral-library-matches/{matchId}/annotated',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_structure_annotated_spectrum_experimental(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        inchi_key: Annotated[StrictStr, Field(description="2d InChIKey of the structure candidate to be used to annotate the spectrum annotation")],
        spectrum_index: Annotated[Optional[StrictInt], Field(description="index of the spectrum to be annotated. Merged MS/MS will be used if spectrumIndex < 0 (default)")] = None,
        search_prepared: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AnnotatedSpectrum:
        """[EXPERIMENTAL] Returns a fragmentation spectrum annotated with fragments and losses for the given formulaId and inChIKey  

        [EXPERIMENTAL] Returns a fragmentation spectrum annotated with fragments and losses for the given formulaId and inChIKey  <p>  Returns a fragmentation spectrum (e.g. Merged MS/MS) which is annotated with fragments and losses for the selected formula result  These annotations are only available if a fragmentation tree is available.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param inchi_key: 2d InChIKey of the structure candidate to be used to annotate the spectrum annotation (required)
        :type inchi_key: str
        :param spectrum_index: index of the spectrum to be annotated. Merged MS/MS will be used if spectrumIndex < 0 (default)
        :type spectrum_index: int
        :param search_prepared:
        :type search_prepared: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_annotated_spectrum_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            inchi_key=inchi_key,
            spectrum_index=spectrum_index,
            search_prepared=search_prepared,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnnotatedSpectrum",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_structure_annotated_spectrum_experimental_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        inchi_key: Annotated[StrictStr, Field(description="2d InChIKey of the structure candidate to be used to annotate the spectrum annotation")],
        spectrum_index: Annotated[Optional[StrictInt], Field(description="index of the spectrum to be annotated. Merged MS/MS will be used if spectrumIndex < 0 (default)")] = None,
        search_prepared: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AnnotatedSpectrum]:
        """[EXPERIMENTAL] Returns a fragmentation spectrum annotated with fragments and losses for the given formulaId and inChIKey  

        [EXPERIMENTAL] Returns a fragmentation spectrum annotated with fragments and losses for the given formulaId and inChIKey  <p>  Returns a fragmentation spectrum (e.g. Merged MS/MS) which is annotated with fragments and losses for the selected formula result  These annotations are only available if a fragmentation tree is available.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param inchi_key: 2d InChIKey of the structure candidate to be used to annotate the spectrum annotation (required)
        :type inchi_key: str
        :param spectrum_index: index of the spectrum to be annotated. Merged MS/MS will be used if spectrumIndex < 0 (default)
        :type spectrum_index: int
        :param search_prepared:
        :type search_prepared: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_annotated_spectrum_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            inchi_key=inchi_key,
            spectrum_index=spectrum_index,
            search_prepared=search_prepared,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnnotatedSpectrum",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_structure_annotated_spectrum_experimental_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        inchi_key: Annotated[StrictStr, Field(description="2d InChIKey of the structure candidate to be used to annotate the spectrum annotation")],
        spectrum_index: Annotated[Optional[StrictInt], Field(description="index of the spectrum to be annotated. Merged MS/MS will be used if spectrumIndex < 0 (default)")] = None,
        search_prepared: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """[EXPERIMENTAL] Returns a fragmentation spectrum annotated with fragments and losses for the given formulaId and inChIKey  

        [EXPERIMENTAL] Returns a fragmentation spectrum annotated with fragments and losses for the given formulaId and inChIKey  <p>  Returns a fragmentation spectrum (e.g. Merged MS/MS) which is annotated with fragments and losses for the selected formula result  These annotations are only available if a fragmentation tree is available.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param inchi_key: 2d InChIKey of the structure candidate to be used to annotate the spectrum annotation (required)
        :type inchi_key: str
        :param spectrum_index: index of the spectrum to be annotated. Merged MS/MS will be used if spectrumIndex < 0 (default)
        :type spectrum_index: int
        :param search_prepared:
        :type search_prepared: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_annotated_spectrum_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            inchi_key=inchi_key,
            spectrum_index=spectrum_index,
            search_prepared=search_prepared,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnnotatedSpectrum",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_structure_annotated_spectrum_experimental_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        inchi_key,
        spectrum_index,
        search_prepared,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        if inchi_key is not None:
            _path_params['inchiKey'] = inchi_key
        # process the query parameters
        if spectrum_index is not None:
            
            _query_params.append(('spectrumIndex', spectrum_index))
            
        if search_prepared is not None:
            
            _query_params.append(('searchPrepared', search_prepared))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/structures/{inchiKey}/annotated-spectrum',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_structure_candidates(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        opt_fields: Annotated[Optional[List[StructureCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[StructureCandidateFormula]:
        """List of structure database search candidates ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.

        List of structure database search candidates ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidateFormula]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_structure_candidates_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        opt_fields: Annotated[Optional[List[StructureCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[StructureCandidateFormula]]:
        """List of structure database search candidates ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.

        List of structure database search candidates ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidateFormula]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_structure_candidates_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        opt_fields: Annotated[Optional[List[StructureCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List of structure database search candidates ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.

        List of structure database search candidates ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidateFormula]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_structure_candidates_serialize(
        self,
        project_id,
        aligned_feature_id,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/db-structures',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_structure_candidates_by_formula(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        opt_fields: Annotated[Optional[List[StructureCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[StructureCandidateScored]:
        """List of CSI:FingerID structure database search candidates for the given 'formulaId' with minimal information.

        List of CSI:FingerID structure database search candidates for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_by_formula_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidateScored]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_structure_candidates_by_formula_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        opt_fields: Annotated[Optional[List[StructureCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[StructureCandidateScored]]:
        """List of CSI:FingerID structure database search candidates for the given 'formulaId' with minimal information.

        List of CSI:FingerID structure database search candidates for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_by_formula_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidateScored]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_structure_candidates_by_formula_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        opt_fields: Annotated[Optional[List[StructureCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List of CSI:FingerID structure database search candidates for the given 'formulaId' with minimal information.

        List of CSI:FingerID structure database search candidates for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_by_formula_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidateScored]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_structure_candidates_by_formula_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/db-structures',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_structure_candidates_by_formula_paged(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[StructureCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PagedModelStructureCandidateScored:
        """Page of CSI:FingerID structure database search candidates for the given 'formulaId' with minimal information.

        Page of CSI:FingerID structure database search candidates for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_by_formula_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelStructureCandidateScored",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_structure_candidates_by_formula_paged_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[StructureCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PagedModelStructureCandidateScored]:
        """Page of CSI:FingerID structure database search candidates for the given 'formulaId' with minimal information.

        Page of CSI:FingerID structure database search candidates for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_by_formula_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelStructureCandidateScored",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_structure_candidates_by_formula_paged_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[StructureCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Page of CSI:FingerID structure database search candidates for the given 'formulaId' with minimal information.

        Page of CSI:FingerID structure database search candidates for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_by_formula_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelStructureCandidateScored",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_structure_candidates_by_formula_paged_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        page,
        size,
        sort,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort': 'multi',
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/db-structures/page',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_structure_candidates_paged(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[StructureCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PagedModelStructureCandidateFormula:
        """Page of structure database search candidates ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.

        Page of structure database search candidates ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelStructureCandidateFormula",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_structure_candidates_paged_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[StructureCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PagedModelStructureCandidateFormula]:
        """Page of structure database search candidates ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.

        Page of structure database search candidates ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelStructureCandidateFormula",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_structure_candidates_paged_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[StructureCandidateOptField]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Page of structure database search candidates ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.

        Page of structure database search candidates ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelStructureCandidateFormula",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_structure_candidates_paged_serialize(
        self,
        project_id,
        aligned_feature_id,
        page,
        size,
        sort,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort': 'multi',
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/db-structures/page',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_tags_for_aligned_features_experimental(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to get from.")],
        object_id: Annotated[StrictStr, Field(description="object to get tags for.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Tag]:
        """[EXPERIMENTAL] Get all tags associated with this Object

        [EXPERIMENTAL] Get all tags associated with this Object

        :param project_id: project-space to get from. (required)
        :type project_id: str
        :param object_id: object to get tags for. (required)
        :type object_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tags_for_aligned_features_experimental_serialize(
            project_id=project_id,
            object_id=object_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Tag]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_tags_for_aligned_features_experimental_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to get from.")],
        object_id: Annotated[StrictStr, Field(description="object to get tags for.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Tag]]:
        """[EXPERIMENTAL] Get all tags associated with this Object

        [EXPERIMENTAL] Get all tags associated with this Object

        :param project_id: project-space to get from. (required)
        :type project_id: str
        :param object_id: object to get tags for. (required)
        :type object_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tags_for_aligned_features_experimental_serialize(
            project_id=project_id,
            object_id=object_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Tag]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_tags_for_aligned_features_experimental_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to get from.")],
        object_id: Annotated[StrictStr, Field(description="object to get tags for.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """[EXPERIMENTAL] Get all tags associated with this Object

        [EXPERIMENTAL] Get all tags associated with this Object

        :param project_id: project-space to get from. (required)
        :type project_id: str
        :param object_id: object to get tags for. (required)
        :type object_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tags_for_aligned_features_experimental_serialize(
            project_id=project_id,
            object_id=object_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Tag]",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_tags_for_aligned_features_experimental_serialize(
        self,
        project_id,
        object_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if object_id is not None:
            _path_params['objectId'] = object_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/tags/{objectId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_traces_experimental(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature which intensities should be read out")],
        include_all: Annotated[Optional[StrictBool], Field(description="when true, return all samples that belong to the same merged trace. when false, only return samples which contain the aligned feature.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TraceSetExperimental:
        """[EXPERIMENTAL] Returns the traces of the given feature (alignedFeatureId)

        [EXPERIMENTAL] Returns the traces of the given feature (alignedFeatureId).  <p>  Returns the traces of the given feature. A trace consists of m/z and intensity values over the retention  time axis. All the returned traces are 'projected', which means they refer not to the original retention time axis,  but to a recalibrated axis. This means the data points in the trace are not exactly the same as in the raw data.  However, this also means that all traces can be directly compared against each other, as they all lie in the same  retention time axis.  By default, this method only returns traces of samples the aligned feature appears in. When includeAll is set,  it also includes samples in which the same trace appears in.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature which intensities should be read out (required)
        :type aligned_feature_id: str
        :param include_all: when true, return all samples that belong to the same merged trace. when false, only return samples which contain the aligned feature.
        :type include_all: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_traces_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            include_all=include_all,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TraceSetExperimental",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_traces_experimental_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature which intensities should be read out")],
        include_all: Annotated[Optional[StrictBool], Field(description="when true, return all samples that belong to the same merged trace. when false, only return samples which contain the aligned feature.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TraceSetExperimental]:
        """[EXPERIMENTAL] Returns the traces of the given feature (alignedFeatureId)

        [EXPERIMENTAL] Returns the traces of the given feature (alignedFeatureId).  <p>  Returns the traces of the given feature. A trace consists of m/z and intensity values over the retention  time axis. All the returned traces are 'projected', which means they refer not to the original retention time axis,  but to a recalibrated axis. This means the data points in the trace are not exactly the same as in the raw data.  However, this also means that all traces can be directly compared against each other, as they all lie in the same  retention time axis.  By default, this method only returns traces of samples the aligned feature appears in. When includeAll is set,  it also includes samples in which the same trace appears in.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature which intensities should be read out (required)
        :type aligned_feature_id: str
        :param include_all: when true, return all samples that belong to the same merged trace. when false, only return samples which contain the aligned feature.
        :type include_all: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_traces_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            include_all=include_all,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TraceSetExperimental",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_traces_experimental_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature which intensities should be read out")],
        include_all: Annotated[Optional[StrictBool], Field(description="when true, return all samples that belong to the same merged trace. when false, only return samples which contain the aligned feature.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """[EXPERIMENTAL] Returns the traces of the given feature (alignedFeatureId)

        [EXPERIMENTAL] Returns the traces of the given feature (alignedFeatureId).  <p>  Returns the traces of the given feature. A trace consists of m/z and intensity values over the retention  time axis. All the returned traces are 'projected', which means they refer not to the original retention time axis,  but to a recalibrated axis. This means the data points in the trace are not exactly the same as in the raw data.  However, this also means that all traces can be directly compared against each other, as they all lie in the same  retention time axis.  By default, this method only returns traces of samples the aligned feature appears in. When includeAll is set,  it also includes samples in which the same trace appears in.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature which intensities should be read out (required)
        :type aligned_feature_id: str
        :param include_all: when true, return all samples that belong to the same merged trace. when false, only return samples which contain the aligned feature.
        :type include_all: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_traces_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            include_all=include_all,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TraceSetExperimental",
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_traces_experimental_serialize(
        self,
        project_id,
        aligned_feature_id,
        include_all,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        if include_all is not None:
            
            _query_params.append(('includeAll', include_all))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/traces',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def remove_tag_from_aligned_feature_experimental(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to delete from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) to delete tag from.")],
        tag_name: Annotated[StrictStr, Field(description="name of the tag to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """[EXPERIMENTAL] Delete tag with the given name from the feature (aligned over runs) with the specified ID in the specified project-space

        [EXPERIMENTAL] Delete tag with the given name from the feature (aligned over runs) with the specified ID in the specified project-space.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to delete from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) to delete tag from. (required)
        :type aligned_feature_id: str
        :param tag_name: name of the tag to delete. (required)
        :type tag_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_tag_from_aligned_feature_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            tag_name=tag_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def remove_tag_from_aligned_feature_experimental_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to delete from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) to delete tag from.")],
        tag_name: Annotated[StrictStr, Field(description="name of the tag to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """[EXPERIMENTAL] Delete tag with the given name from the feature (aligned over runs) with the specified ID in the specified project-space

        [EXPERIMENTAL] Delete tag with the given name from the feature (aligned over runs) with the specified ID in the specified project-space.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to delete from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) to delete tag from. (required)
        :type aligned_feature_id: str
        :param tag_name: name of the tag to delete. (required)
        :type tag_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_tag_from_aligned_feature_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            tag_name=tag_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def remove_tag_from_aligned_feature_experimental_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to delete from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) to delete tag from.")],
        tag_name: Annotated[StrictStr, Field(description="name of the tag to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """[EXPERIMENTAL] Delete tag with the given name from the feature (aligned over runs) with the specified ID in the specified project-space

        [EXPERIMENTAL] Delete tag with the given name from the feature (aligned over runs) with the specified ID in the specified project-space.  <p>  [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.

        :param project_id: project-space to delete from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) to delete tag from. (required)
        :type aligned_feature_id: str
        :param tag_name: name of the tag to delete. (required)
        :type tag_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_tag_from_aligned_feature_experimental_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            tag_name=tag_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _remove_tag_from_aligned_feature_experimental_serialize(
        self,
        project_id,
        aligned_feature_id,
        tag_name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if tag_name is not None:
            _path_params['tagName'] = tag_name
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/projects/{projectId}/aligned-features/tags/{alignedFeatureId}/{tagName}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


