# coding: utf-8

"""
    SIRIUS Nightsky API


    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr
from typing import List, Optional
from typing_extensions import Annotated
from PySirius.models.aligned_feature import AlignedFeature
from PySirius.models.aligned_feature_opt_field import AlignedFeatureOptField
from PySirius.models.annotated_ms_ms_data import AnnotatedMsMsData
from PySirius.models.annotated_spectrum import AnnotatedSpectrum
from PySirius.models.canopus_prediction import CanopusPrediction
from PySirius.models.compound_classes import CompoundClasses
from PySirius.models.feature_import import FeatureImport
from PySirius.models.formula_candidate import FormulaCandidate
from PySirius.models.formula_candidate_opt_field import FormulaCandidateOptField
from PySirius.models.fragmentation_tree import FragmentationTree
from PySirius.models.instrument_profile import InstrumentProfile
from PySirius.models.isotope_pattern_annotation import IsotopePatternAnnotation
from PySirius.models.lipid_annotation import LipidAnnotation
from PySirius.models.ms_data import MsData
from PySirius.models.paged_model_aligned_feature import PagedModelAlignedFeature
from PySirius.models.paged_model_formula_candidate import PagedModelFormulaCandidate
from PySirius.models.paged_model_spectral_library_match import PagedModelSpectralLibraryMatch
from PySirius.models.paged_model_structure_candidate_formula import PagedModelStructureCandidateFormula
from PySirius.models.paged_model_structure_candidate_scored import PagedModelStructureCandidateScored
from PySirius.models.spectral_library_match import SpectralLibraryMatch
from PySirius.models.spectral_library_match_opt_field import SpectralLibraryMatchOptField
from PySirius.models.spectral_library_match_summary import SpectralLibraryMatchSummary
from PySirius.models.structure_candidate_formula import StructureCandidateFormula
from PySirius.models.structure_candidate_opt_field import StructureCandidateOptField
from PySirius.models.structure_candidate_scored import StructureCandidateScored

from PySirius.api_client import ApiClient, RequestSerialized
from PySirius.api_response import ApiResponse
from PySirius.rest import RESTResponseType


class FeaturesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def add_aligned_features(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to import into.")],
        feature_import: Annotated[List[FeatureImport], Field(description="the feature data to be imported")],
        profile: Annotated[Optional[InstrumentProfile], Field(description="profile describing the instrument used to measure the data. Used to merge spectra.")] = None,
        opt_fields: Annotated[Optional[List[Optional[AlignedFeatureOptField]]], Field(description="set of optional fields to be included. Use 'none' to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[AlignedFeature]:
        """Import (aligned) features into the project.

        Import (aligned) features into the project. Features must not exist in the project.  Otherwise, they will exist twice.

        :param project_id: project-space to import into. (required)
        :type project_id: str
        :param feature_import: the feature data to be imported (required)
        :type feature_import: List[FeatureImport]
        :param profile: profile describing the instrument used to measure the data. Used to merge spectra.
        :type profile: InstrumentProfile
        :param opt_fields: set of optional fields to be included. Use 'none' to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_aligned_features_serialize(
            project_id=project_id,
            feature_import=feature_import,
            profile=profile,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AlignedFeature]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def add_aligned_features_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to import into.")],
        feature_import: Annotated[List[FeatureImport], Field(description="the feature data to be imported")],
        profile: Annotated[Optional[InstrumentProfile], Field(description="profile describing the instrument used to measure the data. Used to merge spectra.")] = None,
        opt_fields: Annotated[Optional[List[Optional[AlignedFeatureOptField]]], Field(description="set of optional fields to be included. Use 'none' to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[AlignedFeature]]:
        """Import (aligned) features into the project.

        Import (aligned) features into the project. Features must not exist in the project.  Otherwise, they will exist twice.

        :param project_id: project-space to import into. (required)
        :type project_id: str
        :param feature_import: the feature data to be imported (required)
        :type feature_import: List[FeatureImport]
        :param profile: profile describing the instrument used to measure the data. Used to merge spectra.
        :type profile: InstrumentProfile
        :param opt_fields: set of optional fields to be included. Use 'none' to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_aligned_features_serialize(
            project_id=project_id,
            feature_import=feature_import,
            profile=profile,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AlignedFeature]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def add_aligned_features_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to import into.")],
        feature_import: Annotated[List[FeatureImport], Field(description="the feature data to be imported")],
        profile: Annotated[Optional[InstrumentProfile], Field(description="profile describing the instrument used to measure the data. Used to merge spectra.")] = None,
        opt_fields: Annotated[Optional[List[Optional[AlignedFeatureOptField]]], Field(description="set of optional fields to be included. Use 'none' to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Import (aligned) features into the project.

        Import (aligned) features into the project. Features must not exist in the project.  Otherwise, they will exist twice.

        :param project_id: project-space to import into. (required)
        :type project_id: str
        :param feature_import: the feature data to be imported (required)
        :type feature_import: List[FeatureImport]
        :param profile: profile describing the instrument used to measure the data. Used to merge spectra.
        :type profile: InstrumentProfile
        :param opt_fields: set of optional fields to be included. Use 'none' to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_aligned_features_serialize(
            project_id=project_id,
            feature_import=feature_import,
            profile=profile,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AlignedFeature]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _add_aligned_features_serialize(
        self,
        project_id,
        feature_import,
        profile,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'FeatureImport': '',
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        # process the query parameters
        if profile is not None:
            
            _query_params.append(('profile', profile.value))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if feature_import is not None:
            _body_params = feature_import


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/projects/{projectId}/aligned-features',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_aligned_feature(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to delete from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="identifier of feature (aligned over runs) to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete feature (aligned over runs) with the given identifier from the specified project-space.

        Delete feature (aligned over runs) with the given identifier from the specified project-space.

        :param project_id: project-space to delete from. (required)
        :type project_id: str
        :param aligned_feature_id: identifier of feature (aligned over runs) to delete. (required)
        :type aligned_feature_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_aligned_feature_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_aligned_feature_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to delete from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="identifier of feature (aligned over runs) to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete feature (aligned over runs) with the given identifier from the specified project-space.

        Delete feature (aligned over runs) with the given identifier from the specified project-space.

        :param project_id: project-space to delete from. (required)
        :type project_id: str
        :param aligned_feature_id: identifier of feature (aligned over runs) to delete. (required)
        :type aligned_feature_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_aligned_feature_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_aligned_feature_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to delete from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="identifier of feature (aligned over runs) to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete feature (aligned over runs) with the given identifier from the specified project-space.

        Delete feature (aligned over runs) with the given identifier from the specified project-space.

        :param project_id: project-space to delete from. (required)
        :type project_id: str
        :param aligned_feature_id: identifier of feature (aligned over runs) to delete. (required)
        :type aligned_feature_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_aligned_feature_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_aligned_feature_serialize(
        self,
        project_id,
        aligned_feature_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_aligned_features(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to delete from.")],
        request_body: List[StrictStr],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete feature (aligned over runs) with the given identifier from the specified project-space.

        Delete feature (aligned over runs) with the given identifier from the specified project-space.

        :param project_id: project-space to delete from. (required)
        :type project_id: str
        :param request_body: (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_aligned_features_serialize(
            project_id=project_id,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_aligned_features_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to delete from.")],
        request_body: List[StrictStr],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete feature (aligned over runs) with the given identifier from the specified project-space.

        Delete feature (aligned over runs) with the given identifier from the specified project-space.

        :param project_id: project-space to delete from. (required)
        :type project_id: str
        :param request_body: (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_aligned_features_serialize(
            project_id=project_id,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_aligned_features_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to delete from.")],
        request_body: List[StrictStr],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete feature (aligned over runs) with the given identifier from the specified project-space.

        Delete feature (aligned over runs) with the given identifier from the specified project-space.

        :param project_id: project-space to delete from. (required)
        :type project_id: str
        :param request_body: (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_aligned_features_serialize(
            project_id=project_id,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_aligned_features_serialize(
        self,
        project_id,
        request_body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'request_body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/projects/{projectId}/aligned-features/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_aligned_feature(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="identifier of feature (aligned over runs) to access.")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[Optional[AlignedFeatureOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AlignedFeature:
        """Get feature (aligned over runs) with the given identifier from the specified project-space.

        Get feature (aligned over runs) with the given identifier from the specified project-space.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: identifier of feature (aligned over runs) to access. (required)
        :type aligned_feature_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_feature_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AlignedFeature",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_aligned_feature_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="identifier of feature (aligned over runs) to access.")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[Optional[AlignedFeatureOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AlignedFeature]:
        """Get feature (aligned over runs) with the given identifier from the specified project-space.

        Get feature (aligned over runs) with the given identifier from the specified project-space.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: identifier of feature (aligned over runs) to access. (required)
        :type aligned_feature_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_feature_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AlignedFeature",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_aligned_feature_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="identifier of feature (aligned over runs) to access.")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[Optional[AlignedFeatureOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get feature (aligned over runs) with the given identifier from the specified project-space.

        Get feature (aligned over runs) with the given identifier from the specified project-space.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: identifier of feature (aligned over runs) to access. (required)
        :type aligned_feature_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_feature_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AlignedFeature",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_aligned_feature_serialize(
        self,
        project_id,
        aligned_feature_id,
        ms_data_search_prepared,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        if ms_data_search_prepared is not None:
            
            _query_params.append(('msDataSearchPrepared', ms_data_search_prepared))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_aligned_features(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[Optional[AlignedFeatureOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[AlignedFeature]:
        """Get all available features (aligned over runs) in the given project-space.

        Get all available features (aligned over runs) in the given project-space.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_features_serialize(
            project_id=project_id,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AlignedFeature]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_aligned_features_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[Optional[AlignedFeatureOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[AlignedFeature]]:
        """Get all available features (aligned over runs) in the given project-space.

        Get all available features (aligned over runs) in the given project-space.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_features_serialize(
            project_id=project_id,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AlignedFeature]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_aligned_features_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[Optional[AlignedFeatureOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get all available features (aligned over runs) in the given project-space.

        Get all available features (aligned over runs) in the given project-space.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_features_serialize(
            project_id=project_id,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AlignedFeature]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_aligned_features_serialize(
        self,
        project_id,
        ms_data_search_prepared,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        # process the query parameters
        if ms_data_search_prepared is not None:
            
            _query_params.append(('msDataSearchPrepared', ms_data_search_prepared))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_aligned_features_paged(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[Optional[AlignedFeatureOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PagedModelAlignedFeature:
        """Get all available features (aligned over runs) in the given project-space.

        Get all available features (aligned over runs) in the given project-space.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_features_paged_serialize(
            project_id=project_id,
            page=page,
            size=size,
            sort=sort,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelAlignedFeature",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_aligned_features_paged_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[Optional[AlignedFeatureOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PagedModelAlignedFeature]:
        """Get all available features (aligned over runs) in the given project-space.

        Get all available features (aligned over runs) in the given project-space.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_features_paged_serialize(
            project_id=project_id,
            page=page,
            size=size,
            sort=sort,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelAlignedFeature",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_aligned_features_paged_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[Optional[AlignedFeatureOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get all available features (aligned over runs) in the given project-space.

        Get all available features (aligned over runs) in the given project-space.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[AlignedFeatureOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_aligned_features_paged_serialize(
            project_id=project_id,
            page=page,
            size=size,
            sort=sort,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelAlignedFeature",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_aligned_features_paged_serialize(
        self,
        project_id,
        page,
        size,
        sort,
        ms_data_search_prepared,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort': 'multi',
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if ms_data_search_prepared is not None:
            
            _query_params.append(('msDataSearchPrepared', ms_data_search_prepared))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/page',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_best_matching_compound_classes(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CompoundClasses:
        """Return Best matching compound classes for given formulaId

        Return Best matching compound classes for given formulaId.  <p>  Set of the highest scoring compound classes (CANOPUS) on each hierarchy level of  the ClassyFire and NPC ontology,

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_best_matching_compound_classes_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CompoundClasses",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_best_matching_compound_classes_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CompoundClasses]:
        """Return Best matching compound classes for given formulaId

        Return Best matching compound classes for given formulaId.  <p>  Set of the highest scoring compound classes (CANOPUS) on each hierarchy level of  the ClassyFire and NPC ontology,

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_best_matching_compound_classes_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CompoundClasses",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_best_matching_compound_classes_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return Best matching compound classes for given formulaId

        Return Best matching compound classes for given formulaId.  <p>  Set of the highest scoring compound classes (CANOPUS) on each hierarchy level of  the ClassyFire and NPC ontology,

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_best_matching_compound_classes_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CompoundClasses",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_best_matching_compound_classes_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/best-compound-classes',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_canopus_prediction(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CanopusPrediction:
        """All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,

        All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_canopus_prediction_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CanopusPrediction",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_canopus_prediction_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CanopusPrediction]:
        """All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,

        All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_canopus_prediction_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CanopusPrediction",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_canopus_prediction_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,

        All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_canopus_prediction_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CanopusPrediction",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_canopus_prediction_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/canopus-prediction',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_de_novo_structure_candidates_by_formula(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        opt_fields: Annotated[Optional[List[Optional[StructureCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[StructureCandidateScored]:
        """List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_de_novo_structure_candidates_by_formula_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidateScored]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_de_novo_structure_candidates_by_formula_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        opt_fields: Annotated[Optional[List[Optional[StructureCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[StructureCandidateScored]]:
        """List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_de_novo_structure_candidates_by_formula_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidateScored]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_de_novo_structure_candidates_by_formula_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        opt_fields: Annotated[Optional[List[Optional[StructureCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_de_novo_structure_candidates_by_formula_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidateScored]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_de_novo_structure_candidates_by_formula_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/denovo-structures',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_de_novo_structure_candidates_by_formula_paged(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[Optional[StructureCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PagedModelStructureCandidateScored:
        """Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_de_novo_structure_candidates_by_formula_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelStructureCandidateScored",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_de_novo_structure_candidates_by_formula_paged_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[Optional[StructureCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PagedModelStructureCandidateScored]:
        """Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_de_novo_structure_candidates_by_formula_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelStructureCandidateScored",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_de_novo_structure_candidates_by_formula_paged_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[Optional[StructureCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_de_novo_structure_candidates_by_formula_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelStructureCandidateScored",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_de_novo_structure_candidates_by_formula_paged_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        page,
        size,
        sort,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort': 'multi',
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/denovo-structures/page',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_de_novo_structure_candidates_paged(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[Optional[StructureCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PagedModelStructureCandidateFormula:
        """Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_de_novo_structure_candidates_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelStructureCandidateFormula",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_de_novo_structure_candidates_paged_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[Optional[StructureCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PagedModelStructureCandidateFormula]:
        """Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_de_novo_structure_candidates_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelStructureCandidateFormula",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_de_novo_structure_candidates_paged_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[Optional[StructureCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_de_novo_structure_candidates_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelStructureCandidateFormula",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_de_novo_structure_candidates_paged_serialize(
        self,
        project_id,
        aligned_feature_id,
        page,
        size,
        sort,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort': 'multi',
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/denovo-structures/page',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_fingerprint_prediction(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[float]:
        """Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier (formulaId)  

        Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier (formulaId)  <p>  This fingerprint is used to perform structure database search and predict compound classes.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_prediction_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[float]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_fingerprint_prediction_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[float]]:
        """Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier (formulaId)  

        Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier (formulaId)  <p>  This fingerprint is used to perform structure database search and predict compound classes.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_prediction_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[float]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_fingerprint_prediction_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier (formulaId)  

        Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier (formulaId)  <p>  This fingerprint is used to perform structure database search and predict compound classes.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_prediction_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[float]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_fingerprint_prediction_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/fingerprint',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_formula_annotated_ms_ms_data(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AnnotatedMsMsData:
        """Returns MS/MS Spectrum annotated with fragments and losses for provided formulaId

        Returns MS/MS Spectrum annotated with fragments and losses for provided formulaId.  <p>  Returns MS/MS Spectrum (Merged MS/MS and measured MS/MS) which is annotated with fragments and losses  for the given formula result identifier  These annotations are only available if a fragmentation tree and the structure candidate are available.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_annotated_ms_ms_data_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            ms_data_search_prepared=ms_data_search_prepared,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnnotatedMsMsData",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_formula_annotated_ms_ms_data_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AnnotatedMsMsData]:
        """Returns MS/MS Spectrum annotated with fragments and losses for provided formulaId

        Returns MS/MS Spectrum annotated with fragments and losses for provided formulaId.  <p>  Returns MS/MS Spectrum (Merged MS/MS and measured MS/MS) which is annotated with fragments and losses  for the given formula result identifier  These annotations are only available if a fragmentation tree and the structure candidate are available.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_annotated_ms_ms_data_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            ms_data_search_prepared=ms_data_search_prepared,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnnotatedMsMsData",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_formula_annotated_ms_ms_data_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns MS/MS Spectrum annotated with fragments and losses for provided formulaId

        Returns MS/MS Spectrum annotated with fragments and losses for provided formulaId.  <p>  Returns MS/MS Spectrum (Merged MS/MS and measured MS/MS) which is annotated with fragments and losses  for the given formula result identifier  These annotations are only available if a fragmentation tree and the structure candidate are available.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_annotated_ms_ms_data_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            ms_data_search_prepared=ms_data_search_prepared,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnnotatedMsMsData",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_formula_annotated_ms_ms_data_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        ms_data_search_prepared,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        if ms_data_search_prepared is not None:
            
            _query_params.append(('msDataSearchPrepared', ms_data_search_prepared))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/annotated-msmsdata',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_formula_annotated_spectrum(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        spectrum_index: Annotated[Optional[StrictInt], Field(description="index of the spectrum to be annotated. Merged MS/MS will be used if spectrumIndex < 0 (default)")] = None,
        search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AnnotatedSpectrum:
        """Returns a fragmentation spectrum (e

        Returns a fragmentation spectrum (e.g. Merged MS/MS) which is annotated with fragments and losses for the given formula result identifier  <p>  These annotations are only available if a fragmentation tree is available.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param spectrum_index: index of the spectrum to be annotated. Merged MS/MS will be used if spectrumIndex < 0 (default)
        :type spectrum_index: int
        :param search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.
        :type search_prepared: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_annotated_spectrum_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            spectrum_index=spectrum_index,
            search_prepared=search_prepared,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnnotatedSpectrum",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_formula_annotated_spectrum_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        spectrum_index: Annotated[Optional[StrictInt], Field(description="index of the spectrum to be annotated. Merged MS/MS will be used if spectrumIndex < 0 (default)")] = None,
        search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AnnotatedSpectrum]:
        """Returns a fragmentation spectrum (e

        Returns a fragmentation spectrum (e.g. Merged MS/MS) which is annotated with fragments and losses for the given formula result identifier  <p>  These annotations are only available if a fragmentation tree is available.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param spectrum_index: index of the spectrum to be annotated. Merged MS/MS will be used if spectrumIndex < 0 (default)
        :type spectrum_index: int
        :param search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.
        :type search_prepared: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_annotated_spectrum_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            spectrum_index=spectrum_index,
            search_prepared=search_prepared,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnnotatedSpectrum",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_formula_annotated_spectrum_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        spectrum_index: Annotated[Optional[StrictInt], Field(description="index of the spectrum to be annotated. Merged MS/MS will be used if spectrumIndex < 0 (default)")] = None,
        search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns a fragmentation spectrum (e

        Returns a fragmentation spectrum (e.g. Merged MS/MS) which is annotated with fragments and losses for the given formula result identifier  <p>  These annotations are only available if a fragmentation tree is available.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param spectrum_index: index of the spectrum to be annotated. Merged MS/MS will be used if spectrumIndex < 0 (default)
        :type spectrum_index: int
        :param search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.
        :type search_prepared: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_annotated_spectrum_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            spectrum_index=spectrum_index,
            search_prepared=search_prepared,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnnotatedSpectrum",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_formula_annotated_spectrum_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        spectrum_index,
        search_prepared,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        if spectrum_index is not None:
            
            _query_params.append(('spectrumIndex', spectrum_index))
            
        if search_prepared is not None:
            
            _query_params.append(('searchPrepared', search_prepared))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/annotated-spectrum',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_formula_candidate(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[Optional[FormulaCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FormulaCandidate:
        """FormulaResultContainers for the given 'formulaId' with minimal information.

        FormulaResultContainers for the given 'formulaId' with minimal information.  Can be enriched with an optional results overview and formula candidate information.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[FormulaCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_candidate_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FormulaCandidate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_formula_candidate_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[Optional[FormulaCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FormulaCandidate]:
        """FormulaResultContainers for the given 'formulaId' with minimal information.

        FormulaResultContainers for the given 'formulaId' with minimal information.  Can be enriched with an optional results overview and formula candidate information.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[FormulaCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_candidate_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FormulaCandidate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_formula_candidate_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[Optional[FormulaCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """FormulaResultContainers for the given 'formulaId' with minimal information.

        FormulaResultContainers for the given 'formulaId' with minimal information.  Can be enriched with an optional results overview and formula candidate information.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[FormulaCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_candidate_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FormulaCandidate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_formula_candidate_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        ms_data_search_prepared,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        if ms_data_search_prepared is not None:
            
            _query_params.append(('msDataSearchPrepared', ms_data_search_prepared))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_formula_candidates(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[Optional[FormulaCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[FormulaCandidate]:
        """List of FormulaResultContainers available for this feature with minimal information.

        List of FormulaResultContainers available for this feature with minimal information.  Can be enriched with an optional results overview.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[FormulaCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_candidates_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FormulaCandidate]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_formula_candidates_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[Optional[FormulaCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[FormulaCandidate]]:
        """List of FormulaResultContainers available for this feature with minimal information.

        List of FormulaResultContainers available for this feature with minimal information.  Can be enriched with an optional results overview.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[FormulaCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_candidates_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FormulaCandidate]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_formula_candidates_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[Optional[FormulaCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List of FormulaResultContainers available for this feature with minimal information.

        List of FormulaResultContainers available for this feature with minimal information.  Can be enriched with an optional results overview.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[FormulaCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_candidates_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FormulaCandidate]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_formula_candidates_serialize(
        self,
        project_id,
        aligned_feature_id,
        ms_data_search_prepared,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        if ms_data_search_prepared is not None:
            
            _query_params.append(('msDataSearchPrepared', ms_data_search_prepared))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_formula_candidates_paged(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[Optional[FormulaCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PagedModelFormulaCandidate:
        """Page of FormulaResultContainers available for this feature with minimal information.

        Page of FormulaResultContainers available for this feature with minimal information.  Can be enriched with an optional results overview.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[FormulaCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_candidates_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            page=page,
            size=size,
            sort=sort,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelFormulaCandidate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_formula_candidates_paged_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[Optional[FormulaCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PagedModelFormulaCandidate]:
        """Page of FormulaResultContainers available for this feature with minimal information.

        Page of FormulaResultContainers available for this feature with minimal information.  Can be enriched with an optional results overview.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[FormulaCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_candidates_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            page=page,
            size=size,
            sort=sort,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelFormulaCandidate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_formula_candidates_paged_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.")] = None,
        opt_fields: Annotated[Optional[List[Optional[FormulaCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Page of FormulaResultContainers available for this feature with minimal information.

        Page of FormulaResultContainers available for this feature with minimal information.  Can be enriched with an optional results overview.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                             Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                             peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[FormulaCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_candidates_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            page=page,
            size=size,
            sort=sort,
            ms_data_search_prepared=ms_data_search_prepared,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelFormulaCandidate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_formula_candidates_paged_serialize(
        self,
        project_id,
        aligned_feature_id,
        page,
        size,
        sort,
        ms_data_search_prepared,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort': 'multi',
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if ms_data_search_prepared is not None:
            
            _query_params.append(('msDataSearchPrepared', ms_data_search_prepared))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/page',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_frag_tree(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FragmentationTree:
        """Returns fragmentation tree (SIRIUS) for the given formula result identifier  

        Returns fragmentation tree (SIRIUS) for the given formula result identifier  <p>  This tree is used to rank formula candidates (treeScore).

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_frag_tree_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FragmentationTree",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_frag_tree_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FragmentationTree]:
        """Returns fragmentation tree (SIRIUS) for the given formula result identifier  

        Returns fragmentation tree (SIRIUS) for the given formula result identifier  <p>  This tree is used to rank formula candidates (treeScore).

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_frag_tree_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FragmentationTree",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_frag_tree_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns fragmentation tree (SIRIUS) for the given formula result identifier  

        Returns fragmentation tree (SIRIUS) for the given formula result identifier  <p>  This tree is used to rank formula candidates (treeScore).

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_frag_tree_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FragmentationTree",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_frag_tree_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/fragtree',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_isotope_pattern_annotation(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IsotopePatternAnnotation:
        """Returns Isotope pattern information for given formulaId  

        Returns Isotope pattern information for given formulaId  <p>  Returns Isotope pattern information (simulated isotope pattern, measured isotope pattern, isotope pattern highlighting)  for the given formula result identifier. This simulated isotope pattern is used to rank formula candidates (treeScore).

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_isotope_pattern_annotation_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IsotopePatternAnnotation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_isotope_pattern_annotation_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IsotopePatternAnnotation]:
        """Returns Isotope pattern information for given formulaId  

        Returns Isotope pattern information for given formulaId  <p>  Returns Isotope pattern information (simulated isotope pattern, measured isotope pattern, isotope pattern highlighting)  for the given formula result identifier. This simulated isotope pattern is used to rank formula candidates (treeScore).

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_isotope_pattern_annotation_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IsotopePatternAnnotation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_isotope_pattern_annotation_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns Isotope pattern information for given formulaId  

        Returns Isotope pattern information for given formulaId  <p>  Returns Isotope pattern information (simulated isotope pattern, measured isotope pattern, isotope pattern highlighting)  for the given formula result identifier. This simulated isotope pattern is used to rank formula candidates (treeScore).

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_isotope_pattern_annotation_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IsotopePatternAnnotation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_isotope_pattern_annotation_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/isotope-pattern',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_lipid_annotation(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> LipidAnnotation:
        """Returns Lipid annotation (ElGordo) for the given formulaId

        Returns Lipid annotation (ElGordo) for the given formulaId.  <p>  ElGordo lipid annotation runs as part of the SIRIUS formula identification step.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_lipid_annotation_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LipidAnnotation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_lipid_annotation_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[LipidAnnotation]:
        """Returns Lipid annotation (ElGordo) for the given formulaId

        Returns Lipid annotation (ElGordo) for the given formulaId.  <p>  ElGordo lipid annotation runs as part of the SIRIUS formula identification step.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_lipid_annotation_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LipidAnnotation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_lipid_annotation_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns Lipid annotation (ElGordo) for the given formulaId

        Returns Lipid annotation (ElGordo) for the given formulaId.  <p>  ElGordo lipid annotation runs as part of the SIRIUS formula identification step.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_lipid_annotation_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LipidAnnotation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_lipid_annotation_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/lipid-annotation',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_ms_data(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the Mass Spec data belongs to.")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MsData:
        """Mass Spec data (input data) for the given 'alignedFeatureId' .

        Mass Spec data (input data) for the given 'alignedFeatureId' .

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the Mass Spec data belongs to. (required)
        :type aligned_feature_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ms_data_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            ms_data_search_prepared=ms_data_search_prepared,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MsData",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_ms_data_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the Mass Spec data belongs to.")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MsData]:
        """Mass Spec data (input data) for the given 'alignedFeatureId' .

        Mass Spec data (input data) for the given 'alignedFeatureId' .

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the Mass Spec data belongs to. (required)
        :type aligned_feature_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ms_data_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            ms_data_search_prepared=ms_data_search_prepared,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MsData",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_ms_data_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the Mass Spec data belongs to.")],
        ms_data_search_prepared: Annotated[Optional[StrictBool], Field(description="Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Mass Spec data (input data) for the given 'alignedFeatureId' .

        Mass Spec data (input data) for the given 'alignedFeatureId' .

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the Mass Spec data belongs to. (required)
        :type aligned_feature_id: str
        :param ms_data_search_prepared: Returns all fragment spectra in a preprocessed form as used for fast                          Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch                          peak assignments and reference spectra.
        :type ms_data_search_prepared: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ms_data_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            ms_data_search_prepared=ms_data_search_prepared,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MsData",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_ms_data_serialize(
        self,
        project_id,
        aligned_feature_id,
        ms_data_search_prepared,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        if ms_data_search_prepared is not None:
            
            _query_params.append(('msDataSearchPrepared', ms_data_search_prepared))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/ms-data',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_spectral_library_match(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        match_id: Annotated[StrictStr, Field(description="id of the library match to be returned.")],
        opt_fields: Optional[List[Optional[SpectralLibraryMatchOptField]]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SpectralLibraryMatch:
        """Spectral library match for the given 'alignedFeatureId'.

        Spectral library match for the given 'alignedFeatureId'.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param match_id: id of the library match to be returned. (required)
        :type match_id: str
        :param opt_fields:
        :type opt_fields: List[SpectralLibraryMatchOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spectral_library_match_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            match_id=match_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpectralLibraryMatch",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_spectral_library_match_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        match_id: Annotated[StrictStr, Field(description="id of the library match to be returned.")],
        opt_fields: Optional[List[Optional[SpectralLibraryMatchOptField]]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SpectralLibraryMatch]:
        """Spectral library match for the given 'alignedFeatureId'.

        Spectral library match for the given 'alignedFeatureId'.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param match_id: id of the library match to be returned. (required)
        :type match_id: str
        :param opt_fields:
        :type opt_fields: List[SpectralLibraryMatchOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spectral_library_match_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            match_id=match_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpectralLibraryMatch",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_spectral_library_match_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        match_id: Annotated[StrictStr, Field(description="id of the library match to be returned.")],
        opt_fields: Optional[List[Optional[SpectralLibraryMatchOptField]]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Spectral library match for the given 'alignedFeatureId'.

        Spectral library match for the given 'alignedFeatureId'.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param match_id: id of the library match to be returned. (required)
        :type match_id: str
        :param opt_fields:
        :type opt_fields: List[SpectralLibraryMatchOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spectral_library_match_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            match_id=match_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpectralLibraryMatch",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_spectral_library_match_serialize(
        self,
        project_id,
        aligned_feature_id,
        match_id,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if match_id is not None:
            _path_params['matchId'] = match_id
        # process the query parameters
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/spectral-library-matches/{matchId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_spectral_library_matches(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        min_shared_peaks: Optional[StrictInt] = None,
        min_similarity: Optional[float] = None,
        inchi_key: Optional[StrictStr] = None,
        opt_fields: Optional[List[Optional[SpectralLibraryMatchOptField]]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[SpectralLibraryMatch]:
        """List of spectral library matches for the given 'alignedFeatureId'.

        List of spectral library matches for the given 'alignedFeatureId'.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param min_shared_peaks:
        :type min_shared_peaks: int
        :param min_similarity:
        :type min_similarity: float
        :param inchi_key:
        :type inchi_key: str
        :param opt_fields:
        :type opt_fields: List[SpectralLibraryMatchOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spectral_library_matches_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            min_shared_peaks=min_shared_peaks,
            min_similarity=min_similarity,
            inchi_key=inchi_key,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SpectralLibraryMatch]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_spectral_library_matches_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        min_shared_peaks: Optional[StrictInt] = None,
        min_similarity: Optional[float] = None,
        inchi_key: Optional[StrictStr] = None,
        opt_fields: Optional[List[Optional[SpectralLibraryMatchOptField]]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[SpectralLibraryMatch]]:
        """List of spectral library matches for the given 'alignedFeatureId'.

        List of spectral library matches for the given 'alignedFeatureId'.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param min_shared_peaks:
        :type min_shared_peaks: int
        :param min_similarity:
        :type min_similarity: float
        :param inchi_key:
        :type inchi_key: str
        :param opt_fields:
        :type opt_fields: List[SpectralLibraryMatchOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spectral_library_matches_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            min_shared_peaks=min_shared_peaks,
            min_similarity=min_similarity,
            inchi_key=inchi_key,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SpectralLibraryMatch]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_spectral_library_matches_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        min_shared_peaks: Optional[StrictInt] = None,
        min_similarity: Optional[float] = None,
        inchi_key: Optional[StrictStr] = None,
        opt_fields: Optional[List[Optional[SpectralLibraryMatchOptField]]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List of spectral library matches for the given 'alignedFeatureId'.

        List of spectral library matches for the given 'alignedFeatureId'.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param min_shared_peaks:
        :type min_shared_peaks: int
        :param min_similarity:
        :type min_similarity: float
        :param inchi_key:
        :type inchi_key: str
        :param opt_fields:
        :type opt_fields: List[SpectralLibraryMatchOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spectral_library_matches_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            min_shared_peaks=min_shared_peaks,
            min_similarity=min_similarity,
            inchi_key=inchi_key,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SpectralLibraryMatch]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_spectral_library_matches_serialize(
        self,
        project_id,
        aligned_feature_id,
        min_shared_peaks,
        min_similarity,
        inchi_key,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        if min_shared_peaks is not None:
            
            _query_params.append(('minSharedPeaks', min_shared_peaks))
            
        if min_similarity is not None:
            
            _query_params.append(('minSimilarity', min_similarity))
            
        if inchi_key is not None:
            
            _query_params.append(('inchiKey', inchi_key))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/spectral-library-matches',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_spectral_library_matches_paged(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        min_shared_peaks: Optional[StrictInt] = None,
        min_similarity: Optional[float] = None,
        inchi_key: Optional[StrictStr] = None,
        opt_fields: Optional[List[Optional[SpectralLibraryMatchOptField]]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PagedModelSpectralLibraryMatch:
        """Page of spectral library matches for the given 'alignedFeatureId'.

        Page of spectral library matches for the given 'alignedFeatureId'.  If a 'inchiKey' (2D) is provided, returns only matches for the database compound with the given InChI key.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param min_shared_peaks:
        :type min_shared_peaks: int
        :param min_similarity:
        :type min_similarity: float
        :param inchi_key:
        :type inchi_key: str
        :param opt_fields:
        :type opt_fields: List[SpectralLibraryMatchOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spectral_library_matches_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            page=page,
            size=size,
            sort=sort,
            min_shared_peaks=min_shared_peaks,
            min_similarity=min_similarity,
            inchi_key=inchi_key,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelSpectralLibraryMatch",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_spectral_library_matches_paged_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        min_shared_peaks: Optional[StrictInt] = None,
        min_similarity: Optional[float] = None,
        inchi_key: Optional[StrictStr] = None,
        opt_fields: Optional[List[Optional[SpectralLibraryMatchOptField]]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PagedModelSpectralLibraryMatch]:
        """Page of spectral library matches for the given 'alignedFeatureId'.

        Page of spectral library matches for the given 'alignedFeatureId'.  If a 'inchiKey' (2D) is provided, returns only matches for the database compound with the given InChI key.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param min_shared_peaks:
        :type min_shared_peaks: int
        :param min_similarity:
        :type min_similarity: float
        :param inchi_key:
        :type inchi_key: str
        :param opt_fields:
        :type opt_fields: List[SpectralLibraryMatchOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spectral_library_matches_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            page=page,
            size=size,
            sort=sort,
            min_shared_peaks=min_shared_peaks,
            min_similarity=min_similarity,
            inchi_key=inchi_key,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelSpectralLibraryMatch",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_spectral_library_matches_paged_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        min_shared_peaks: Optional[StrictInt] = None,
        min_similarity: Optional[float] = None,
        inchi_key: Optional[StrictStr] = None,
        opt_fields: Optional[List[Optional[SpectralLibraryMatchOptField]]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Page of spectral library matches for the given 'alignedFeatureId'.

        Page of spectral library matches for the given 'alignedFeatureId'.  If a 'inchiKey' (2D) is provided, returns only matches for the database compound with the given InChI key.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param min_shared_peaks:
        :type min_shared_peaks: int
        :param min_similarity:
        :type min_similarity: float
        :param inchi_key:
        :type inchi_key: str
        :param opt_fields:
        :type opt_fields: List[SpectralLibraryMatchOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spectral_library_matches_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            page=page,
            size=size,
            sort=sort,
            min_shared_peaks=min_shared_peaks,
            min_similarity=min_similarity,
            inchi_key=inchi_key,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelSpectralLibraryMatch",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_spectral_library_matches_paged_serialize(
        self,
        project_id,
        aligned_feature_id,
        page,
        size,
        sort,
        min_shared_peaks,
        min_similarity,
        inchi_key,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort': 'multi',
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if min_shared_peaks is not None:
            
            _query_params.append(('minSharedPeaks', min_shared_peaks))
            
        if min_similarity is not None:
            
            _query_params.append(('minSimilarity', min_similarity))
            
        if inchi_key is not None:
            
            _query_params.append(('inchiKey', inchi_key))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/spectral-library-matches/page',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_spectral_library_matches_summary(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        min_shared_peaks: Annotated[Optional[StrictInt], Field(description="min threshold of shared peaks.")] = None,
        min_similarity: Annotated[Optional[float], Field(description="min spectral similarity threshold.")] = None,
        inchi_key: Annotated[Optional[StrictStr], Field(description="2D inchi key of the compound in the structure database.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SpectralLibraryMatchSummary:
        """Summarize matched reference spectra for the given 'alignedFeatureId'.

        Summarize matched reference spectra for the given 'alignedFeatureId'.  If a 'inchiKey' (2D) is provided, summarizes only contains matches for the database compound with the given InChI key.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param min_shared_peaks: min threshold of shared peaks.
        :type min_shared_peaks: int
        :param min_similarity: min spectral similarity threshold.
        :type min_similarity: float
        :param inchi_key: 2D inchi key of the compound in the structure database.
        :type inchi_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spectral_library_matches_summary_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            min_shared_peaks=min_shared_peaks,
            min_similarity=min_similarity,
            inchi_key=inchi_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpectralLibraryMatchSummary",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_spectral_library_matches_summary_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        min_shared_peaks: Annotated[Optional[StrictInt], Field(description="min threshold of shared peaks.")] = None,
        min_similarity: Annotated[Optional[float], Field(description="min spectral similarity threshold.")] = None,
        inchi_key: Annotated[Optional[StrictStr], Field(description="2D inchi key of the compound in the structure database.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SpectralLibraryMatchSummary]:
        """Summarize matched reference spectra for the given 'alignedFeatureId'.

        Summarize matched reference spectra for the given 'alignedFeatureId'.  If a 'inchiKey' (2D) is provided, summarizes only contains matches for the database compound with the given InChI key.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param min_shared_peaks: min threshold of shared peaks.
        :type min_shared_peaks: int
        :param min_similarity: min spectral similarity threshold.
        :type min_similarity: float
        :param inchi_key: 2D inchi key of the compound in the structure database.
        :type inchi_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spectral_library_matches_summary_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            min_shared_peaks=min_shared_peaks,
            min_similarity=min_similarity,
            inchi_key=inchi_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpectralLibraryMatchSummary",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_spectral_library_matches_summary_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        min_shared_peaks: Annotated[Optional[StrictInt], Field(description="min threshold of shared peaks.")] = None,
        min_similarity: Annotated[Optional[float], Field(description="min spectral similarity threshold.")] = None,
        inchi_key: Annotated[Optional[StrictStr], Field(description="2D inchi key of the compound in the structure database.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Summarize matched reference spectra for the given 'alignedFeatureId'.

        Summarize matched reference spectra for the given 'alignedFeatureId'.  If a 'inchiKey' (2D) is provided, summarizes only contains matches for the database compound with the given InChI key.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param min_shared_peaks: min threshold of shared peaks.
        :type min_shared_peaks: int
        :param min_similarity: min spectral similarity threshold.
        :type min_similarity: float
        :param inchi_key: 2D inchi key of the compound in the structure database.
        :type inchi_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spectral_library_matches_summary_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            min_shared_peaks=min_shared_peaks,
            min_similarity=min_similarity,
            inchi_key=inchi_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpectralLibraryMatchSummary",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_spectral_library_matches_summary_serialize(
        self,
        project_id,
        aligned_feature_id,
        min_shared_peaks,
        min_similarity,
        inchi_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        if min_shared_peaks is not None:
            
            _query_params.append(('minSharedPeaks', min_shared_peaks))
            
        if min_similarity is not None:
            
            _query_params.append(('minSimilarity', min_similarity))
            
        if inchi_key is not None:
            
            _query_params.append(('inchiKey', inchi_key))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/spectral-library-matches/summary',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_structure_candidates(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        opt_fields: Annotated[Optional[List[Optional[StructureCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[StructureCandidateFormula]:
        """List of structure database search candidates ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.

        List of structure database search candidates ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidateFormula]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_structure_candidates_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        opt_fields: Annotated[Optional[List[Optional[StructureCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[StructureCandidateFormula]]:
        """List of structure database search candidates ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.

        List of structure database search candidates ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidateFormula]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_structure_candidates_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        opt_fields: Annotated[Optional[List[Optional[StructureCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List of structure database search candidates ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.

        List of structure database search candidates ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidateFormula]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_structure_candidates_serialize(
        self,
        project_id,
        aligned_feature_id,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/db-structures',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_structure_candidates_by_formula(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        opt_fields: Annotated[Optional[List[Optional[StructureCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[StructureCandidateScored]:
        """List of CSI:FingerID structure database search candidates for the given 'formulaId' with minimal information.

        List of CSI:FingerID structure database search candidates for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_by_formula_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidateScored]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_structure_candidates_by_formula_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        opt_fields: Annotated[Optional[List[Optional[StructureCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[StructureCandidateScored]]:
        """List of CSI:FingerID structure database search candidates for the given 'formulaId' with minimal information.

        List of CSI:FingerID structure database search candidates for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_by_formula_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidateScored]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_structure_candidates_by_formula_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        opt_fields: Annotated[Optional[List[Optional[StructureCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List of CSI:FingerID structure database search candidates for the given 'formulaId' with minimal information.

        List of CSI:FingerID structure database search candidates for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_by_formula_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidateScored]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_structure_candidates_by_formula_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/db-structures',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_structure_candidates_by_formula_paged(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[Optional[StructureCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PagedModelStructureCandidateScored:
        """Page of CSI:FingerID structure database search candidates for the given 'formulaId' with minimal information.

        Page of CSI:FingerID structure database search candidates for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_by_formula_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelStructureCandidateScored",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_structure_candidates_by_formula_paged_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[Optional[StructureCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PagedModelStructureCandidateScored]:
        """Page of CSI:FingerID structure database search candidates for the given 'formulaId' with minimal information.

        Page of CSI:FingerID structure database search candidates for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_by_formula_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelStructureCandidateScored",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_structure_candidates_by_formula_paged_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[Optional[StructureCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Page of CSI:FingerID structure database search candidates for the given 'formulaId' with minimal information.

        Page of CSI:FingerID structure database search candidates for the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the formula result belongs to. (required)
        :type aligned_feature_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_by_formula_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            formula_id=formula_id,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelStructureCandidateScored",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_structure_candidates_by_formula_paged_serialize(
        self,
        project_id,
        aligned_feature_id,
        formula_id,
        page,
        size,
        sort,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort': 'multi',
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/db-structures/page',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_structure_candidates_paged(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[Optional[StructureCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PagedModelStructureCandidateFormula:
        """Page of structure database search candidates ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.

        Page of structure database search candidates ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelStructureCandidateFormula",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_structure_candidates_paged_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[Optional[StructureCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PagedModelStructureCandidateFormula]:
        """Page of structure database search candidates ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.

        Page of structure database search candidates ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelStructureCandidateFormula",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_structure_candidates_paged_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        aligned_feature_id: Annotated[StrictStr, Field(description="feature (aligned over runs) the structure candidates belong to.")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        opt_fields: Annotated[Optional[List[Optional[StructureCandidateOptField]]], Field(description="set of optional fields to be included. Use 'none' only to override defaults.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Page of structure database search candidates ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.

        Page of structure database search candidates ranked by CSI:FingerID score for the given 'alignedFeatureId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param aligned_feature_id: feature (aligned over runs) the structure candidates belong to. (required)
        :type aligned_feature_id: str
        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param opt_fields: set of optional fields to be included. Use 'none' only to override defaults.
        :type opt_fields: List[StructureCandidateOptField]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_paged_serialize(
            project_id=project_id,
            aligned_feature_id=aligned_feature_id,
            page=page,
            size=size,
            sort=sort,
            opt_fields=opt_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedModelStructureCandidateFormula",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_structure_candidates_paged_serialize(
        self,
        project_id,
        aligned_feature_id,
        page,
        size,
        sort,
        opt_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort': 'multi',
            'optFields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if aligned_feature_id is not None:
            _path_params['alignedFeatureId'] = aligned_feature_id
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if opt_fields is not None:
            
            _query_params.append(('optFields', opt_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/aligned-features/{alignedFeatureId}/db-structures/page',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


