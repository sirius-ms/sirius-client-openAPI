# coding: utf-8

"""
    SIRIUS Nightsky API

    REST API that provides the full functionality of SIRIUS and its web services as background service. It is intended as entry-point for scripting languages and software integration SDKs.This API is exposed by SIRIUS 6

    The version of the OpenAPI document: 3.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from PySirius.models.computed_subtools import ComputedSubtools
from PySirius.models.data_quality import DataQuality
from PySirius.models.feature_annotations import FeatureAnnotations
from PySirius.models.ms_data import MsData
from PySirius.models.tag import Tag
from typing import Optional, Set
from typing_extensions import Self

class AlignedFeature(BaseModel):
    """
    The AlignedFeature contains the ID of a feature (aligned over runs) together with some read-only information  that might be displayed in some summary view.
    """ # noqa: E501
    aligned_feature_id: Optional[StrictStr] = Field(default=None, alias="alignedFeatureId")
    compound_id: Optional[StrictStr] = Field(default=None, alias="compoundId")
    name: Optional[StrictStr] = None
    external_feature_id: Optional[StrictStr] = Field(default=None, description="Externally provided FeatureId (e.g. by some preprocessing tool).  This FeatureId is NOT used by SIRIUS but is stored to ease mapping information back to the source.", alias="externalFeatureId")
    ion_mass: Optional[float] = Field(default=None, alias="ionMass")
    charge: StrictInt = Field(description="Ion mode (charge) this feature has been measured in.")
    detected_adducts: List[StrictStr] = Field(description="Adducts of this feature that have been detected during preprocessing.", alias="detectedAdducts")
    rt_start_seconds: Optional[float] = Field(default=None, alias="rtStartSeconds")
    rt_end_seconds: Optional[float] = Field(default=None, alias="rtEndSeconds")
    rt_apex_seconds: Optional[float] = Field(default=None, alias="rtApexSeconds")
    quality: Optional[DataQuality] = Field(default=None, description="Quality of this feature.")
    has_ms1: Optional[StrictBool] = Field(default=None, description="If true, the feature has at lease one MS1 spectrum", alias="hasMs1")
    has_ms_ms: Optional[StrictBool] = Field(default=None, description="If true, the feature has at lease one MS/MS spectrum", alias="hasMsMs")
    ms_data: Optional[MsData] = Field(default=None, description="Mass Spec data of this feature (input data)", alias="msData")
    top_annotations: Optional[FeatureAnnotations] = Field(default=None, description="Top annotations of this feature.  If a CSI:FingerID structureAnnotation is available, the FormulaCandidate that corresponds to the  structureAnnotation is returned. Otherwise, it's the FormulaCandidate with the highest SiriusScore is returned.  CANOPUS Compound classes correspond to the FormulaCandidate no matter how it was selected   Null if it was not requested und non-null otherwise.", alias="topAnnotations")
    top_annotations_de_novo: Optional[FeatureAnnotations] = Field(default=None, description="Top de novo annotations of this feature.  The FormulaCandidate with the highest SiriusScore is returned. MSNovelist structureAnnotation and  CANOPUS compoundClasses correspond to the FormulaCandidate.   Null if it was not requested und non-null otherwise.", alias="topAnnotationsDeNovo")
    computing: Optional[StrictBool] = Field(default=None, description="Write lock for this feature. If the feature is locked no write operations are possible.  True if any computation is modifying this feature or its results")
    computed_tools: Optional[ComputedSubtools] = Field(default=None, description="Specifies which tools have been executed for this feature. Can be used to estimate which results can be expected. Null if it was not requested und non-null otherwise.", alias="computedTools")
    tags: Optional[Dict[str, Tag]] = Field(default=None, description="Key: tagName, value: tag")
    __properties: ClassVar[List[str]] = ["alignedFeatureId", "compoundId", "name", "externalFeatureId", "ionMass", "charge", "detectedAdducts", "rtStartSeconds", "rtEndSeconds", "rtApexSeconds", "quality", "hasMs1", "hasMsMs", "msData", "topAnnotations", "topAnnotationsDeNovo", "computing", "computedTools", "tags"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AlignedFeature from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of ms_data
        if self.ms_data:
            _dict['msData'] = self.ms_data.to_dict()
        # override the default output from pydantic by calling `to_dict()` of top_annotations
        if self.top_annotations:
            _dict['topAnnotations'] = self.top_annotations.to_dict()
        # override the default output from pydantic by calling `to_dict()` of top_annotations_de_novo
        if self.top_annotations_de_novo:
            _dict['topAnnotationsDeNovo'] = self.top_annotations_de_novo.to_dict()
        # override the default output from pydantic by calling `to_dict()` of computed_tools
        if self.computed_tools:
            _dict['computedTools'] = self.computed_tools.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in tags (dict)
        _field_dict = {}
        if self.tags:
            for _key_tags in self.tags:
                if self.tags[_key_tags]:
                    _field_dict[_key_tags] = self.tags[_key_tags].to_dict()
            _dict['tags'] = _field_dict
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AlignedFeature from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "alignedFeatureId": obj.get("alignedFeatureId"),
            "compoundId": obj.get("compoundId"),
            "name": obj.get("name"),
            "externalFeatureId": obj.get("externalFeatureId"),
            "ionMass": obj.get("ionMass"),
            "charge": obj.get("charge"),
            "detectedAdducts": obj.get("detectedAdducts"),
            "rtStartSeconds": obj.get("rtStartSeconds"),
            "rtEndSeconds": obj.get("rtEndSeconds"),
            "rtApexSeconds": obj.get("rtApexSeconds"),
            "quality": obj.get("quality"),
            "hasMs1": obj.get("hasMs1"),
            "hasMsMs": obj.get("hasMsMs"),
            "msData": MsData.from_dict(obj["msData"]) if obj.get("msData") is not None else None,
            "topAnnotations": FeatureAnnotations.from_dict(obj["topAnnotations"]) if obj.get("topAnnotations") is not None else None,
            "topAnnotationsDeNovo": FeatureAnnotations.from_dict(obj["topAnnotationsDeNovo"]) if obj.get("topAnnotationsDeNovo") is not None else None,
            "computing": obj.get("computing"),
            "computedTools": ComputedSubtools.from_dict(obj["computedTools"]) if obj.get("computedTools") is not None else None,
            "tags": dict(
                (_k, Tag.from_dict(_v))
                for _k, _v in obj["tags"].items()
            )
            if obj.get("tags") is not None
            else None
        })
        return _obj


