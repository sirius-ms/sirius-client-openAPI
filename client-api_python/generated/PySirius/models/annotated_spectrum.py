# coding: utf-8

"""
    SIRIUS Nightsky API

    REST API that provides the full functionality of SIRIUS and its web services as background service. It is intended as entry-point for scripting languages and software integration SDKs.This API is exposed by SIRIUS 6

    The version of the OpenAPI document: 3.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from PySirius.models.annotated_peak import AnnotatedPeak
from PySirius.models.simple_peak import SimplePeak
from PySirius.models.spectrum_annotation import SpectrumAnnotation
from typing import Optional, Set
from typing_extensions import Self

class AnnotatedSpectrum(BaseModel):
    """
    Spectrum model with peak annotations based on the fragmentation tree and Epimetheus substructure annotations.  Molecular formula and adduct of the spectrum are identical to the ones of the corresponding molecular formula candidate and FragmentationTree.  Fragment molecular formulas and adducts correspond to the FragmentationTree's FragmentNodes
    """ # noqa: E501
    name: Optional[StrictStr] = Field(default=None, description="Optional Displayable name of this spectrum.")
    ms_level: Optional[StrictInt] = Field(default=None, description="MS level of the measured spectrum.  Artificial spectra with no msLevel (e.g. Simulated Isotope patterns) use null or zero", alias="msLevel")
    collision_energy: Optional[StrictStr] = Field(default=None, description="Collision energy used for MS/MS spectra  Null for spectra where collision energy is not applicable", alias="collisionEnergy")
    instrument: Optional[StrictStr] = Field(default=None, description="Instrument information.")
    precursor_mz: Optional[float] = Field(default=None, description="Precursor m/z of the MS/MS spectrum  Null for spectra where precursor m/z is not applicable", alias="precursorMz")
    scan_number: Optional[StrictInt] = Field(default=None, description="Scan number of the spectrum.  Might be null for artificial spectra with no scan number (e.g. Simulated Isotope patterns or merged spectra)", alias="scanNumber")
    cosine_query: StrictBool = Field(description="True if spectrum is in cosine query normalized format.  Such spectrum is compatible with SpectralLibraryMatch peak assignments to reference spectra.", alias="cosineQuery")
    precursor_peak: Optional[SimplePeak] = Field(default=None, description="A separate precursor peak field to either mark the precursor in the peaklist or  provide the precursor peak separately from the spectrum in case the spectrum is in a preprocessed form where  the precursor peak has been removed for library matching.   NULL if the spectrum does not contain the precursor peak.", alias="precursorPeak")
    peaks: List[AnnotatedPeak] = Field(description="The peaks of this spectrum which might contain additional annotations such as molecular formulas.")
    abs_intensity_factor: Optional[float] = Field(default=None, description="Factor to convert relative intensities to absolute intensities.  Might be null or 1 for spectra where absolute intensities are not available (E.g. artificial or merged spectra)  <p>  DEPRECATED: Spectra are always returned with raw intensities.  Use provided normalization factors to normalize on the fly.", alias="absIntensityFactor")
    max_norm_factor: Optional[float] = Field(default=None, description="Factor to convert absolute intensities to MAX norm.", alias="maxNormFactor")
    sum_norm_factor: Optional[float] = Field(default=None, description="Factor to convert absolute intensities to SUM norm.", alias="sumNormFactor")
    l2_norm_factor: Optional[float] = Field(default=None, description="Factor to convert absolute intensities to L2 (Euclidean) norm.", alias="l2NormFactor")
    first_peak_norm_factor: Optional[float] = Field(default=None, description="Factor to convert absolute intensities to normalize intensities by first peak intensity.", alias="firstPeakNormFactor")
    spectrum_annotation: Optional[SpectrumAnnotation] = Field(default=None, description="Optional Annotations of this spectrum.", alias="spectrumAnnotation")
    __properties: ClassVar[List[str]] = ["name", "msLevel", "collisionEnergy", "instrument", "precursorMz", "scanNumber", "cosineQuery", "precursorPeak", "peaks", "absIntensityFactor", "maxNormFactor", "sumNormFactor", "l2NormFactor", "firstPeakNormFactor", "spectrumAnnotation"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AnnotatedSpectrum from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of precursor_peak
        if self.precursor_peak:
            _dict['precursorPeak'] = self.precursor_peak.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in peaks (list)
        _items = []
        if self.peaks:
            for _item_peaks in self.peaks:
                if _item_peaks:
                    _items.append(_item_peaks.to_dict())
            _dict['peaks'] = _items
        # override the default output from pydantic by calling `to_dict()` of spectrum_annotation
        if self.spectrum_annotation:
            _dict['spectrumAnnotation'] = self.spectrum_annotation.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AnnotatedSpectrum from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "name": obj.get("name"),
            "msLevel": obj.get("msLevel"),
            "collisionEnergy": obj.get("collisionEnergy"),
            "instrument": obj.get("instrument"),
            "precursorMz": obj.get("precursorMz"),
            "scanNumber": obj.get("scanNumber"),
            "cosineQuery": obj.get("cosineQuery") if obj.get("cosineQuery") is not None else False,
            "precursorPeak": SimplePeak.from_dict(obj["precursorPeak"]) if obj.get("precursorPeak") is not None else None,
            "peaks": [AnnotatedPeak.from_dict(_item) for _item in obj["peaks"]] if obj.get("peaks") is not None else None,
            "absIntensityFactor": obj.get("absIntensityFactor"),
            "maxNormFactor": obj.get("maxNormFactor"),
            "sumNormFactor": obj.get("sumNormFactor"),
            "l2NormFactor": obj.get("l2NormFactor"),
            "firstPeakNormFactor": obj.get("firstPeakNormFactor"),
            "spectrumAnnotation": SpectrumAnnotation.from_dict(obj["spectrumAnnotation"]) if obj.get("spectrumAnnotation") is not None else None
        })
        return _obj


