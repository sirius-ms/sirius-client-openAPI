# coding: utf-8

"""
    SIRIUS Nightsky API


    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from PySirius.models.instrument_profile import InstrumentProfile
from PySirius.models.isotope_ms2_strategy import IsotopeMs2Strategy
from PySirius.models.timeout import Timeout
from PySirius.models.use_heuristic import UseHeuristic
from typing import Optional, Set
from typing_extensions import Self

class Sirius(BaseModel):
    """
    User/developer friendly parameter subset for the Formula/SIRIUS tool  Can use results from Spectral library search tool.
    """ # noqa: E501
    enabled: Optional[StrictBool] = Field(default=None, description="tags whether the tool is enabled")
    profile: Optional[InstrumentProfile] = Field(default=None, description="Instrument specific profile for internal algorithms  Just select what comes closest to the instrument that was used for measuring the data.")
    number_of_candidates: Optional[StrictInt] = Field(default=None, description="Number of formula candidates to keep as result list (Formula Candidates).", alias="numberOfCandidates")
    number_of_candidates_per_ionization: Optional[StrictInt] = Field(default=None, description="Use this parameter if you want to force SIRIUS to report at least  NumberOfCandidatesPerIonization results per ionization.  if <= 0, this parameter will have no effect and just the top  NumberOfCandidates results will be reported.", alias="numberOfCandidatesPerIonization")
    mass_accuracy_ms2ppm: Optional[float] = Field(default=None, description="Maximum allowed mass deviation. Only molecular formulas within this mass window are considered.", alias="massAccuracyMS2ppm")
    isotope_ms2_settings: Optional[IsotopeMs2Strategy] = Field(default=None, description="Specify how isotope patterns in MS/MS should be handled.  <p>  FILTER: When filtering is enabled, molecular formulas are excluded if their  theoretical isotope pattern does not match the theoretical one, even if their MS/MS pattern has high score.  <p>  SCORE: Use them for SCORING. To use this the instrument should produce clear MS/MS isotope patterns  <p>  IGNORE: Ignore that there might be isotope patterns in MS/MS", alias="isotopeMs2Settings")
    filter_by_isotope_pattern: Optional[StrictBool] = Field(default=None, description="When filtering is enabled, molecular formulas are excluded if their theoretical isotope pattern does not match the theoretical one, even if their MS/MS pattern has high score.", alias="filterByIsotopePattern")
    enforce_el_gordo_formula: Optional[StrictBool] = Field(default=None, description="El Gordo may predict that an MS/MS spectrum is a lipid spectrum. If enabled, the corresponding molecular formula will be enforeced as molecular formula candidate.", alias="enforceElGordoFormula")
    perform_bottom_up_search: Optional[StrictBool] = Field(default=None, description="If true, molecular formula generation via bottom up search is enabled.", alias="performBottomUpSearch")
    perform_denovo_below_mz: Optional[float] = Field(default=None, description="Specifies the m/z below which de novo molecular formula generation is enabled. Set to 0 to disable de novo molecular formula generation.", alias="performDenovoBelowMz")
    formula_search_dbs: Optional[List[StrictStr]] = Field(default=None, description="List Structure database to extract molecular formulas from to reduce formula search space.  SIRIUS is quite good at de novo formula annotation, so only enable if you have a good reason.", alias="formulaSearchDBs")
    apply_formula_constraints_to_db_and_bottom_up_search: Optional[StrictBool] = Field(default=None, description="By default, the formula (element) constraints are only applied to de novo molecular formula generation.  If true, the constraints are as well applied to database search and bottom up search.", alias="applyFormulaConstraintsToDBAndBottomUpSearch")
    enforced_formula_constraints: Optional[StrictStr] = Field(default=None, description="These configurations hold the information how to autodetect elements based on the given formula constraints.  Note: If the compound is already assigned to a specific molecular formula, this annotation is ignored.  <p>  Enforced: Enforced elements are always considered", alias="enforcedFormulaConstraints")
    fallback_formula_constraints: Optional[StrictStr] = Field(default=None, description="These configurations hold the information how to autodetect elements based on the given formula constraints.  Note: If the compound is already assigned to a specific molecular formula, this annotation is ignored.  <p>  Fallback: Fallback elements are used, if the auto-detection fails (e.g. no isotope pattern available)", alias="fallbackFormulaConstraints")
    detectable_elements: Optional[List[StrictStr]] = Field(default=None, description="These configurations hold the information how to autodetect elements based on the given formula constraints.  Note: If the compound is already assigned to a specific molecular formula, this annotation is ignored.  <p>  Detectable: Detectable elements are added to the chemical alphabet, if there are indications for them (e.g. in isotope pattern)", alias="detectableElements")
    ilp_timeout: Optional[Timeout] = Field(default=None, description="Timout settings for the ILP solver used for fragmentation tree computation  secondsPerInstance: Set the maximum number of seconds for computing a single compound. Set to 0 to disable the time constraint.  secondsPerTree: Set the maximum number of seconds for a single molecular formula check. Set to 0 to disable the time constraint", alias="ilpTimeout")
    use_heuristic: Optional[UseHeuristic] = Field(default=None, description="Mass thresholds for heuristic fragmentation tree computation which dramatically speeds up computations.  useHeuristicAboveMz: For compounds above this threshold fragmentation trees will be computed heuristically for ranking. Tree that will be kept (numberOfCandidates) will be recomputed exactly  useOnlyHeuristicAboveMz:For compounds above this threshold fragmentation trees will be computed heuristically.", alias="useHeuristic")
    inject_spec_lib_match_formulas: Optional[StrictBool] = Field(default=None, description="If true formula candidates that belong to spectral library matches above a certain threshold will  we inject/preserved for further analyses no matter which score they have or which filter is applied", alias="injectSpecLibMatchFormulas")
    min_score_to_inject_spec_lib_match: Optional[float] = Field(default=None, description="Similarity Threshold to inject formula candidates no matter which score/rank they have or which filter settings are applied.  If threshold >= 0 formulas candidates with reference spectrum similarity above the threshold will be injected.", alias="minScoreToInjectSpecLibMatch")
    min_peaks_to_inject_spec_lib_match: Optional[StrictInt] = Field(default=None, description="Matching peaks threshold to inject formula candidates no matter which score they have or which filter is applied.", alias="minPeaksToInjectSpecLibMatch")
    __properties: ClassVar[List[str]] = ["enabled", "profile", "numberOfCandidates", "numberOfCandidatesPerIonization", "massAccuracyMS2ppm", "isotopeMs2Settings", "filterByIsotopePattern", "enforceElGordoFormula", "performBottomUpSearch", "performDenovoBelowMz", "formulaSearchDBs", "applyFormulaConstraintsToDBAndBottomUpSearch", "enforcedFormulaConstraints", "fallbackFormulaConstraints", "detectableElements", "ilpTimeout", "useHeuristic", "injectSpecLibMatchFormulas", "minScoreToInjectSpecLibMatch", "minPeaksToInjectSpecLibMatch"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Sirius from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of ilp_timeout
        if self.ilp_timeout:
            _dict['ilpTimeout'] = self.ilp_timeout.to_dict()
        # override the default output from pydantic by calling `to_dict()` of use_heuristic
        if self.use_heuristic:
            _dict['useHeuristic'] = self.use_heuristic.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Sirius from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "enabled": obj.get("enabled"),
            "profile": obj.get("profile"),
            "numberOfCandidates": obj.get("numberOfCandidates"),
            "numberOfCandidatesPerIonization": obj.get("numberOfCandidatesPerIonization"),
            "massAccuracyMS2ppm": obj.get("massAccuracyMS2ppm"),
            "isotopeMs2Settings": obj.get("isotopeMs2Settings"),
            "filterByIsotopePattern": obj.get("filterByIsotopePattern"),
            "enforceElGordoFormula": obj.get("enforceElGordoFormula"),
            "performBottomUpSearch": obj.get("performBottomUpSearch"),
            "performDenovoBelowMz": obj.get("performDenovoBelowMz"),
            "formulaSearchDBs": obj.get("formulaSearchDBs"),
            "applyFormulaConstraintsToDBAndBottomUpSearch": obj.get("applyFormulaConstraintsToDBAndBottomUpSearch"),
            "enforcedFormulaConstraints": obj.get("enforcedFormulaConstraints"),
            "fallbackFormulaConstraints": obj.get("fallbackFormulaConstraints"),
            "detectableElements": obj.get("detectableElements"),
            "ilpTimeout": Timeout.from_dict(obj["ilpTimeout"]) if obj.get("ilpTimeout") is not None else None,
            "useHeuristic": UseHeuristic.from_dict(obj["useHeuristic"]) if obj.get("useHeuristic") is not None else None,
            "injectSpecLibMatchFormulas": obj.get("injectSpecLibMatchFormulas"),
            "minScoreToInjectSpecLibMatch": obj.get("minScoreToInjectSpecLibMatch"),
            "minPeaksToInjectSpecLibMatch": obj.get("minPeaksToInjectSpecLibMatch")
        })
        return _obj


