# Automatically generated by openapi-generator (https://openapi-generator.tech)
# Please update as you see appropriate

context("Test FeaturesApi")
options(warn = -1)

sdk <- SiriusSDK$new()
api <- sdk$attach_to_sirius(sirius_port=8080)
api_instance <- api$features_api
projects_api <- api$projects_api

path_to_demo_data <- paste(Sys.getenv("HOME"), "sirius-client-openAPI/.updater/clientTests/Data", sep = "/")
preproc_ms2_file_1 <- paste(path_to_demo_data, "Kaempferol.ms", sep = "/")
preproc_ms2_file_2 <- paste(path_to_demo_data, "laudanosine.mgf", sep = "/")

# the single ID with MSNovelist AND spectral library search results computed
aligned_feature_id <- "586487310566638367"
tomato_project <- paste(Sys.getenv("HOME"), "tomato_small.sirius", sep = "/")
basic_spectrum <- c(BasicSpectrum$new(peaks = c(SimplePeak$new(1.23, 4.56)), precursorMz = 1.23))
feature_import <- c(FeatureImport$new(name = "testfeature", feature_id = "testfeature", ionMass = 1.23, adduct = "[M+?]+", ms1Spectra = basic_spectrum, ms2Spectra = basic_spectrum))

test_that("AddAlignedFeatures", {
  # tests for AddAlignedFeatures
  # base path: http://localhost:8080
  # Import (aligned) features into the project.
  # Import (aligned) features into the project. Features must not exist in the project.  Otherwise, they will exist twice.
  # @param project_id character project-space to import into.
  # @param feature_import array[FeatureImport] the feature data to be imported
  # @param opt_fields array[AlignedFeatureOptField] set of optional fields to be included. Use 'none' to override defaults. (optional)
  # @return [array[AlignedFeature]]

  tryCatch({

    project_id <- "AddAlignedFeatures"

    project_dir <- paste(Sys.getenv("HOME"), paste0(project_id, ".sirius"), sep = "/")
    project_info <- projects_api$CreateProject(project_id, project_dir)

    response <- api_instance$AddAlignedFeatures(project_id, feature_import)

    expect_true(inherits(response, "list"))
    expect_true(inherits(response[[1]], "AlignedFeature"))

  }, finally = {

    projects_api$CloseProject(project_id)
    unlink(project_info$location, recursive = TRUE)

  })
})

test_that("DeleteAlignedFeature", {
  # tests for DeleteAlignedFeature
  # base path: http://localhost:8080
  # Delete feature (aligned over runs) with the given identifier from the specified project-space.
  # Delete feature (aligned over runs) with the given identifier from the specified project-space.
  # @param project_id character project-space to delete from.
  # @param aligned_feature_id character identifier of feature (aligned over runs) to delete.
  # @return [Void]

  tryCatch({

    project_id <- "DeleteAlignedFeature"

    # we create a new project since we cannot just add data to an existing
    # project that is of different data type like tomato
    project_dir <- paste(Sys.getenv("HOME"), paste0(project_id, ".sirius"), sep = "/")
    project_info <- projects_api$CreateProject(project_id, project_dir)

    var_input_files <- preproc_ms2_file_1
    import <- projects_api$ImportPreprocessedData(project_id, input_files = var_input_files)
    feature_id <- import$affectedAlignedFeatureIds[[1]]

    response_before <- api_instance$GetAlignedFeatures(project_id)
    api_instance$DeleteAlignedFeature(project_id, feature_id)
    response_after <- api_instance$GetAlignedFeatures(project_id)

    expect_equal(length(response_before) - length(response_after), 1)

  }, finally = {

    projects_api$CloseProject(project_id)
    unlink(project_info$location, recursive = TRUE)

  })
})

test_that("DeleteAlignedFeatures", {
  # tests for DeleteAlignedFeatures
  # base path: http://localhost:8080
  # Delete feature (aligned over runs) with the given identifier from the specified project-space.
  # Delete feature (aligned over runs) with the given identifier from the specified project-space.
  # @param project_id character project-space to delete from.
  # @param request_body array[character]
  # @return [Void]

  tryCatch({

    project_id <- "DeleteAlignedFeatures"

    # we create a new project since we cannot just add data to an existing
    # project that is of different data type like tomato
    project_dir <- paste(Sys.getenv("HOME"), paste0(project_id, ".sirius"), sep = "/")
    project_info <- projects_api$CreateProject(project_id, project_dir)

    # multiple files in vector
    var_input_files <- c(preproc_ms2_file_1, preproc_ms2_file_2)
    import <- projects_api$ImportPreprocessedData(project_id, input_files = var_input_files)
    feature_id_1 <- import$affectedAlignedFeatureIds[[1]]
    feature_id_2 <- import$affectedAlignedFeatureIds[[2]]

    response_before <- api_instance$GetAlignedFeatures(project_id)
    api_instance$DeleteAlignedFeatures(project_id, c(feature_id_1, feature_id_2))
    response_after <- api_instance$GetAlignedFeatures(project_id)

    expect_equal(length(response_before) - length(response_after), 2)

  }, finally = {

    projects_api$CloseProject(project_id)
    unlink(project_info$location, recursive = TRUE)

  })
})

test_that("GetAlignedFeature", {
  # tests for GetAlignedFeature
  # base path: http://localhost:8080
  # Get feature (aligned over runs) with the given identifier from the specified project-space.
  # Get feature (aligned over runs) with the given identifier from the specified project-space.
  # @param project_id character project-space to read from.
  # @param aligned_feature_id character identifier of feature (aligned over runs) to access.
  # @param opt_fields array[AlignedFeatureOptField] set of optional fields to be included. Use 'none' only to override defaults. (optional)
  # @return [AlignedFeature]

  tryCatch({

    project_id <- "GetAlignedFeatures"
    projects_api$OpenProject(project_id, tomato_project)

    response <- api_instance$GetAlignedFeature(project_id, aligned_feature_id)
    expect_true(inherits(response, "AlignedFeature"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetAlignedFeatures", {
  # tests for GetAlignedFeatures
  # base path: http://localhost:8080
  # Get all available features (aligned over runs) in the given project-space.
  # Get all available features (aligned over runs) in the given project-space.
  # @param project_id character project-space to read from.
  # @param opt_fields array[AlignedFeatureOptField] set of optional fields to be included. Use 'none' only to override defaults. (optional)
  # @return [array[AlignedFeature]]

  tryCatch({

    project_id <- "GetAlignedFeatures"
    projects_api$OpenProject(project_id, tomato_project)

    response <- api_instance$GetAlignedFeatures(project_id)
    expect_true(inherits(response, "list"))
    expect_true(inherits(response[[1]], "AlignedFeature"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetAlignedFeaturesPaged", {
  # tests for GetAlignedFeaturesPaged
  # base path: http://localhost:8080
  # Get all available features (aligned over runs) in the given project-space.
  # Get all available features (aligned over runs) in the given project-space.
  # @param project_id character project-space to read from.
  # @param page integer Zero-based page index (0..N) (optional)
  # @param size integer The size of the page to be returned (optional)
  # @param sort array[character] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. (optional)
  # @param opt_fields array[AlignedFeatureOptField] set of optional fields to be included. Use 'none' only to override defaults. (optional)
  # @return [PageAlignedFeature]

  tryCatch({

    project_id <- "GetAlignedFeaturesPaged"
    projects_api$OpenProject(project_id, tomato_project)

    response <- api_instance$GetAlignedFeaturesPaged(project_id)
    expect_true(inherits(response, "PagedModelAlignedFeature"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetBestMatchingCompoundClasses", {
  # tests for GetBestMatchingCompoundClasses
  # base path: http://localhost:8080
  # Best matching compound classes,  Set of the highest scoring compound classes (CANOPUS) on each hierarchy level of  the ClassyFire and NPC ontology,
  # Best matching compound classes,  Set of the highest scoring compound classes (CANOPUS) on each hierarchy level of  the ClassyFire and NPC ontology,
  # @param project_id character project-space to read from.
  # @param aligned_feature_id character feature (aligned over runs) the formula result belongs to.
  # @param formula_id character identifier of the requested formula result
  # @return [CompoundClasses]

  tryCatch({

    project_id <- "GetFormulaCandidate"
    projects_api$OpenProject(project_id, tomato_project)
    formula_id <- api_instance$GetFormulaCandidates(project_id, aligned_feature_id)[[1]]$formulaId

    response <- api_instance$GetBestMatchingCompoundClasses(project_id, aligned_feature_id, formula_id)
    expect_true(inherits(response, "CompoundClasses"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetCanopusPrediction", {
  # tests for GetCanopusPrediction
  # base path: http://localhost:8080
  # All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,
  # All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,
  # @param project_id character project-space to read from.
  # @param aligned_feature_id character feature (aligned over runs) the formula result belongs to.
  # @param formula_id character identifier of the requested formula result
  # @return [CanopusPrediction]

  tryCatch({

    project_id <- "GetCanopusPrediction"
    projects_api$OpenProject(project_id, tomato_project)
    formula_id <- api_instance$GetFormulaCandidates(project_id, aligned_feature_id)[[1]]$formulaId

    response <- api_instance$GetCanopusPrediction(project_id, aligned_feature_id, formula_id)
    expect_true(inherits(response, "CanopusPrediction"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetDeNovoStructureCandidatesPaged", {
  # tests for GetDeNovoStructureCandidates
  # base path: http://localhost:8080
  # List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given &#39;alignedFeatureId&#39; with minimal information.  StructureCandidates can be enriched with molecular fingerprint.
  # List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given &#39;alignedFeatureId&#39; with minimal information.  StructureCandidates can be enriched with molecular fingerprint.
  # @param project_id character project-space to read from.
  # @param aligned_feature_id character feature (aligned over runs) the structure candidates belong to.
  # @param opt_fields array[StructureCandidateOptField] set of optional fields to be included. Use 'none' only to override defaults. (optional)
  # @return [array[StructureCandidateFormula]]

  tryCatch({

    project_id <- "GetDeNovoStructureCandidatesPaged"
    projects_api$OpenProject(project_id, tomato_project)

    response <- api_instance$GetDeNovoStructureCandidatesPaged(project_id, aligned_feature_id)
    expect_true(inherits(response, "list"))
    expect_true(inherits(response[[1]], "PagedModelStructureCandidateFormula"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetDeNovoStructureCandidatesByFormula", {
  # tests for GetDeNovoStructureCandidatesByFormula
  # base path: http://localhost:8080
  # List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given &#39;formulaId&#39; with minimal information.  StructureCandidates can be enriched with molecular fingerprint.
  # List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given &#39;formulaId&#39; with minimal information.  StructureCandidates can be enriched with molecular fingerprint.
  # @param project_id character project-space to read from.
  # @param aligned_feature_id character feature (aligned over runs) the formula result belongs to.
  # @param formula_id character identifier of the requested formula result
  # @param opt_fields array[StructureCandidateOptField] set of optional fields to be included. Use 'none' only to override defaults. (optional)
  # @return [array[StructureCandidateScored]]

  tryCatch({

    project_id <- "GetDeNovoStructureCandidatesByFormula"
    projects_api$OpenProject(project_id, tomato_project)
    formula_id <- api_instance$GetFormulaCandidates(project_id, aligned_feature_id)[[1]]$formulaId

    response <- api_instance$GetDeNovoStructureCandidatesByFormula(project_id, aligned_feature_id, formula_id)
    expect_true(inherits(response, "list"))
    expect_true(inherits(response[[1]], "StructureCandidateScored"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetDeNovoStructureCandidatesByFormulaPaged", {
  # tests for GetDeNovoStructureCandidatesByFormulaPaged
  # base path: http://localhost:8080
  # Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given &#39;formulaId&#39; with minimal information.  StructureCandidates can be enriched with molecular fingerprint.
  # Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given &#39;formulaId&#39; with minimal information.  StructureCandidates can be enriched with molecular fingerprint.
  # @param project_id character project-space to read from.
  # @param aligned_feature_id character feature (aligned over runs) the formula result belongs to.
  # @param formula_id character identifier of the requested formula result
  # @param page integer Zero-based page index (0..N) (optional)
  # @param size integer The size of the page to be returned (optional)
  # @param sort array[character] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. (optional)
  # @param opt_fields array[StructureCandidateOptField] set of optional fields to be included. Use 'none' only to override defaults. (optional)
  # @return [PageStructureCandidateScored]

  tryCatch({

    project_id <- "GetDeNovoStructureCandidatesByFormulaPaged"
    projects_api$OpenProject(project_id, tomato_project)
    formula_id <- api_instance$GetFormulaCandidates(project_id, aligned_feature_id)[[1]]$formulaId

    response <- api_instance$GetDeNovoStructureCandidatesByFormulaPaged(project_id, aligned_feature_id, formula_id)
    expect_true(inherits(response, "PagedModelStructureCandidateScored"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetDeNovoStructureCandidatesPaged", {
  # tests for GetDeNovoStructureCandidatesPaged
  # base path: http://localhost:8080
  # Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given &#39;alignedFeatureId&#39; with minimal information.  StructureCandidates can be enriched with molecular fingerprint.
  # Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given &#39;alignedFeatureId&#39; with minimal information.  StructureCandidates can be enriched with molecular fingerprint.
  # @param project_id character project-space to read from.
  # @param aligned_feature_id character feature (aligned over runs) the structure candidates belong to.
  # @param page integer Zero-based page index (0..N) (optional)
  # @param size integer The size of the page to be returned (optional)
  # @param sort array[character] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. (optional)
  # @param opt_fields array[StructureCandidateOptField] set of optional fields to be included. Use 'none' only to override defaults. (optional)
  # @return [PageStructureCandidateFormula]

  tryCatch({

    project_id <- "GetDeNovoStructureCandidatesPaged"
    projects_api$OpenProject(project_id, tomato_project)

    response <- api_instance$GetDeNovoStructureCandidatesPaged(project_id, aligned_feature_id)
    expect_true(inherits(response, "PagedModelStructureCandidateFormula"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetFingerprintPrediction", {
  # tests for GetFingerprintPrediction
  # base path: http://localhost:8080
  # Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier  This fingerprint is used to perform structure database search and predict compound classes.
  # Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier  This fingerprint is used to perform structure database search and predict compound classes.
  # @param project_id character project-space to read from.
  # @param aligned_feature_id character feature (aligned over runs) the formula result belongs to.
  # @param formula_id character identifier of the requested formula result
  # @return [array[numeric]]

  tryCatch({

    project_id <- "GetFingerprintPrediction"
    projects_api$OpenProject(project_id, tomato_project)
    formula_id <- api_instance$GetFormulaCandidates(project_id, aligned_feature_id)[[1]]$formulaId

    response <- api_instance$GetFingerprintPrediction(project_id, aligned_feature_id, formula_id)
    expect_true(inherits(response, "list"))
    expect_true(inherits(response[[1]], "numeric"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetFormulaAnnotatedMsMsData", {
  # tests for GetFormulaAnnotatedMsMsData
  # base path: http://localhost:8080
  # Returns MS/MS Spectrum (Merged MS/MS and measured MS/MS) which is annotated with fragments and losses  for the given formula result identifier  These annotations are only available if a fragmentation tree and the structure candidate are available.
  # Returns MS/MS Spectrum (Merged MS/MS and measured MS/MS) which is annotated with fragments and losses  for the given formula result identifier  These annotations are only available if a fragmentation tree and the structure candidate are available.
  # @param project_id character project-space to read from.
  # @param aligned_feature_id character feature (aligned over runs) the formula result belongs to.
  # @param formula_id character identifier of the requested formula result
  # @return [AnnotatedMsMsData]

  tryCatch({

    project_id <- "GetFormulaAnnotatedMsMsData"
    projects_api$OpenProject(project_id, tomato_project)
    formula_id <- api_instance$GetFormulaCandidates(project_id, aligned_feature_id)[[1]]$formulaId

    response <- api_instance$GetFormulaAnnotatedMsMsData(project_id, aligned_feature_id, formula_id)
    expect_true(inherits(response, "AnnotatedMsMsData"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetFormulaAnnotatedSpectrum", {
  # tests for GetFormulaAnnotatedSpectrum
  # base path: http://localhost:8080
  # Returns a fragmentation spectrum (e.g. Merged MS/MS) which is annotated with fragments and losses for the given formula result identifier  These annotations are only available if a fragmentation tree is available.
  # Returns a fragmentation spectrum (e.g. Merged MS/MS) which is annotated with fragments and losses for the given formula result identifier  These annotations are only available if a fragmentation tree is available.
  # @param project_id character project-space to read from.
  # @param aligned_feature_id character feature (aligned over runs) the formula result belongs to.
  # @param formula_id character identifier of the requested formula result
  # @param spectrum_index integer index of the spectrum to be annotated. Merged MS/MS will be used if spectrumIndex < 0 (default) (optional)
  # @return [AnnotatedSpectrum]

  tryCatch({

    project_id <- "GetFormulaAnnotatedSpectrum"
    projects_api$OpenProject(project_id, tomato_project)
    formula_id <- api_instance$GetFormulaCandidates(project_id, aligned_feature_id)[[1]]$formulaId

    response <- api_instance$GetFormulaAnnotatedSpectrum(project_id, aligned_feature_id, formula_id)
    expect_true(inherits(response, "AnnotatedSpectrum"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetFormulaCandidate", {
  # tests for GetFormulaCandidate
  # base path: http://localhost:8080
  # FormulaResultContainers for the given &#39;formulaId&#39; with minimal information.
  # FormulaResultContainers for the given &#39;formulaId&#39; with minimal information.  Can be enriched with an optional results overview and formula candidate information.
  # @param project_id character project-space to read from.
  # @param aligned_feature_id character feature (aligned over runs) the formula result belongs to.
  # @param formula_id character identifier of the requested formula result
  # @param opt_fields array[FormulaCandidateOptField] set of optional fields to be included. Use 'none' only to override defaults. (optional)
  # @return [FormulaCandidate]

  tryCatch({

    project_id <- "GetFormulaCandidate"
    projects_api$OpenProject(project_id, tomato_project)
    formula_id <- api_instance$GetFormulaCandidates(project_id, aligned_feature_id)[[1]]$formulaId

    response <- api_instance$GetFormulaCandidate(project_id, aligned_feature_id, formula_id)
    expect_true(inherits(response, "FormulaCandidate"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetFormulaCandidates", {
  # tests for GetFormulaCandidates
  # base path: http://localhost:8080
  # List of FormulaResultContainers available for this feature with minimal information.
  # List of FormulaResultContainers available for this feature with minimal information.  Can be enriched with an optional results overview.
  # @param project_id character project-space to read from.
  # @param aligned_feature_id character feature (aligned over runs) the formula result belongs to.
  # @param opt_fields array[FormulaCandidateOptField] set of optional fields to be included. Use 'none' only to override defaults. (optional)
  # @return [array[FormulaCandidate]]

  tryCatch({

    project_id <- "GetFormulaCandidates"
    projects_api$OpenProject(project_id, tomato_project)

    response <- api_instance$GetFormulaCandidates(project_id, aligned_feature_id)
    expect_true(inherits(response, "list"))
    expect_true(inherits(response[[1]], "FormulaCandidate"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetFormulaCandidatesPaged", {
  # tests for GetFormulaCandidatesPaged
  # base path: http://localhost:8080
  # Page of FormulaResultContainers available for this feature with minimal information.
  # Page of FormulaResultContainers available for this feature with minimal information.  Can be enriched with an optional results overview.
  # @param project_id character project-space to read from.
  # @param aligned_feature_id character feature (aligned over runs) the formula result belongs to.
  # @param page integer Zero-based page index (0..N) (optional)
  # @param size integer The size of the page to be returned (optional)
  # @param sort array[character] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. (optional)
  # @param opt_fields array[FormulaCandidateOptField] set of optional fields to be included. Use 'none' only to override defaults. (optional)
  # @return [PageFormulaCandidate]

  tryCatch({

    project_id <- "GetFormulaCandidatesPaged"
    projects_api$OpenProject(project_id, tomato_project)

    response <- api_instance$GetFormulaCandidatesPaged(project_id, aligned_feature_id)
    expect_true(inherits(response, "PagedModelFormulaCandidate"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetFragTree", {
  # tests for GetFragTree
  # base path: http://localhost:8080
  # Returns fragmentation tree (SIRIUS) for the given formula result identifier  This tree is used to rank formula candidates (treeScore).
  # Returns fragmentation tree (SIRIUS) for the given formula result identifier  This tree is used to rank formula candidates (treeScore).
  # @param project_id character project-space to read from.
  # @param aligned_feature_id character feature (aligned over runs) the formula result belongs to.
  # @param formula_id character identifier of the requested formula result
  # @return [FragmentationTree]

  tryCatch({

    project_id <- "GetFragTree"
    projects_api$OpenProject(project_id, tomato_project)
    formula_id <- api_instance$GetFormulaCandidates(project_id, aligned_feature_id)[[1]]$formulaId

    response <- api_instance$GetFragTree(project_id, aligned_feature_id, formula_id)
    expect_true(inherits(response, "FragmentationTree"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetIsotopePatternAnnotation", {
  # tests for GetIsotopePatternAnnotation
  # base path: http://localhost:8080
  # Returns Isotope pattern information (simulated isotope pattern, measured isotope pattern, isotope pattern highlighting)  for the given formula result identifier.
  # Returns Isotope pattern information (simulated isotope pattern, measured isotope pattern, isotope pattern highlighting)  for the given formula result identifier. This simulated isotope pattern is used to rank formula candidates (treeScore).
  # @param project_id character project-space to read from.
  # @param aligned_feature_id character feature (aligned over runs) the formula result belongs to.
  # @param formula_id character identifier of the requested formula result
  # @return [IsotopePatternAnnotation]

  tryCatch({

    project_id <- "GetIsotopePatternAnnotation"
    projects_api$OpenProject(project_id, tomato_project)
    formula_id <- api_instance$GetFormulaCandidates(project_id, aligned_feature_id)[[1]]$formulaId

    response <- api_instance$GetIsotopePatternAnnotation(project_id, aligned_feature_id, formula_id)
    expect_true(inherits(response, "IsotopePatternAnnotation"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetLipidAnnotation", {
  # tests for GetLipidAnnotation
  # base path: http://localhost:8080
  # Returns Lipid annotation (ElGordo) for the given formula result identifier.
  # Returns Lipid annotation (ElGordo) for the given formula result identifier.  ElGordo lipid annotation runs as part of the SIRIUS formula identification step.
  # @param project_id character project-space to read from.
  # @param aligned_feature_id character feature (aligned over runs) the formula result belongs to.
  # @param formula_id character identifier of the requested formula result
  # @return [LipidAnnotation]

  tryCatch({

    project_id <- "GetLipidAnnotation"
    projects_api$OpenProject(project_id, tomato_project)
    formula_id <- api_instance$GetFormulaCandidates(project_id, aligned_feature_id)[[1]]$formulaId

    response <- api_instance$GetLipidAnnotation(project_id, aligned_feature_id, formula_id)
    expect_true(inherits(response, "LipidAnnotation"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetMsData", {
  # tests for GetMsData
  # base path: http://localhost:8080
  # Mass Spec data (input data) for the given &#39;alignedFeatureId&#39; .
  # Mass Spec data (input data) for the given &#39;alignedFeatureId&#39; .
  # @param project_id character project-space to read from.
  # @param aligned_feature_id character feature (aligned over runs) the Mass Spec data belong sto.
  # @return [MsData]

  tryCatch({

    project_id <- "GetMsData"
    projects_api$OpenProject(project_id, tomato_project)

    response <- api_instance$GetMsData(project_id, aligned_feature_id)
    expect_true(inherits(response, "MsData"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetSpectralLibraryMatch", {
  # tests for GetSpectralLibraryMatch
  # base path: http://localhost:8080
  # List of spectral library matches for the given &#39;alignedFeatureId&#39;.
  # List of spectral library matches for the given &#39;alignedFeatureId&#39;.
  # @param project_id character project-space to read from.
  # @param aligned_feature_id character feature (aligned over runs) the structure candidates belong to.
  # @param match_id character
  # @param opt_fields array[SpectralLibraryMatchOptField]  (optional)
  # @return [SpectralLibraryMatch]

  tryCatch({

    project_id <- "GetSpectralLibraryMatch"
    projects_api$OpenProject(project_id, tomato_project)
    match_id <- api_instance$GetSpectralLibraryMatches(project_id, aligned_feature_id)[[1]]$specMatchId

    response <- api_instance$GetSpectralLibraryMatch(project_id, aligned_feature_id, match_id)
    expect_true(inherits(response, "SpectralLibraryMatch"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetSpectralLibraryMatches", {
  # tests for GetSpectralLibraryMatches
  # base path: http://localhost:8080
  # List of spectral library matches for the given &#39;alignedFeatureId&#39;.
  # List of spectral library matches for the given &#39;alignedFeatureId&#39;.
  # @param project_id character project-space to read from.
  # @param aligned_feature_id character feature (aligned over runs) the structure candidates belong to.
  # @param min_shared_peaks integer  (optional)
  # @param min_similarity numeric  (optional)
  # @param candidate_in_chi_key character  (optional)
  # @param opt_fields array[SpectralLibraryMatchOptField]  (optional)
  # @return [array[SpectralLibraryMatch]]

  tryCatch({

    project_id <- "GetSpectralLibraryMatches"
    projects_api$OpenProject(project_id, tomato_project)

    response <- api_instance$GetSpectralLibraryMatches(project_id, aligned_feature_id)
    expect_true(inherits(response, "list"))
    expect_true(inherits(response[[1]], "SpectralLibraryMatch"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetSpectralLibraryMatchesPaged", {
  # tests for GetSpectralLibraryMatchesPaged
  # base path: http://localhost:8080
  # Page of spectral library matches for the given &#39;alignedFeatureId&#39;.
  # Page of spectral library matches for the given &#39;alignedFeatureId&#39;.  If a &#39;candidateInChiKey&#39; is provided, returns only matches for the database compound with the given InChI key.
  # @param project_id character project-space to read from.
  # @param aligned_feature_id character feature (aligned over runs) the structure candidates belong to.
  # @param page integer Zero-based page index (0..N) (optional)
  # @param size integer The size of the page to be returned (optional)
  # @param sort array[character] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. (optional)
  # @param min_shared_peaks integer  (optional)
  # @param min_similarity numeric  (optional)
  # @param candidate_in_chi_key character  (optional)
  # @param opt_fields array[SpectralLibraryMatchOptField]  (optional)
  # @return [PageSpectralLibraryMatch]

  tryCatch({

    project_id <- "GetSpectralLibraryMatchesPaged"
    projects_api$OpenProject(project_id, tomato_project)

    response <- api_instance$GetSpectralLibraryMatchesPaged(project_id, aligned_feature_id)
    expect_true(inherits(response, "PagedModelSpectralLibraryMatch"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetSpectralLibraryMatchesSummary", {
  # tests for GetSpectralLibraryMatchesSummary
  # base path: http://localhost:8080
  # Summarize matched reference spectra for the given &#39;alignedFeatureId&#39;.
  # Summarize matched reference spectra for the given &#39;alignedFeatureId&#39;.  If a &#39;candidateInChiKey&#39; is provided, summarizes only matches for the database compound with the given InChI key.
  # @param project_id character project-space to read from.
  # @param aligned_feature_id character feature (aligned over runs) the structure candidates belong to.
  # @param min_shared_peaks integer min threshold of shared peaks. (optional)
  # @param min_similarity numeric min spectral similarity threshold. (optional)
  # @param candidate_in_chi_key character inchi key of the database compound. (optional)
  # @return [SpectralLibraryMatchSummary]

  tryCatch({

    project_id <- "GetSpectralLibraryMatchesSummary"
    projects_api$OpenProject(project_id, tomato_project)

    response <- api_instance$GetSpectralLibraryMatchesSummary(project_id, aligned_feature_id)
    expect_true(inherits(response, "SpectralLibraryMatchSummary"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetStructureCandidates", {
  # tests for GetStructureCandidates
  # base path: http://localhost:8080
  # List of structure database search candidates ranked by CSI:FingerID score for the given &#39;alignedFeatureId&#39; with minimal information.
  # List of structure database search candidates ranked by CSI:FingerID score for the given &#39;alignedFeatureId&#39; with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.
  # @param project_id character project-space to read from.
  # @param aligned_feature_id character feature (aligned over runs) the structure candidates belong to.
  # @param opt_fields array[StructureCandidateOptField] set of optional fields to be included. Use 'none' only to override defaults. (optional)
  # @return [array[StructureCandidateFormula]]

  tryCatch({

    project_id <- "GetStructureCandidates"
    projects_api$OpenProject(project_id, tomato_project)

    response <- api_instance$GetStructureCandidates(project_id, aligned_feature_id)
    expect_true(inherits(response, "list"))
    expect_true(inherits(response[[1]], "StructureCandidateFormula"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetStructureCandidatesByFormula", {
  # tests for GetStructureCandidatesByFormula
  # base path: http://localhost:8080
  # List of CSI:FingerID structure database search candidates for the given &#39;formulaId&#39; with minimal information.
  # List of CSI:FingerID structure database search candidates for the given &#39;formulaId&#39; with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.
  # @param project_id character project-space to read from.
  # @param aligned_feature_id character feature (aligned over runs) the formula result belongs to.
  # @param formula_id character identifier of the requested formula result
  # @param opt_fields array[StructureCandidateOptField] set of optional fields to be included. Use 'none' only to override defaults. (optional)
  # @return [array[StructureCandidateScored]]

  tryCatch({

    project_id <- "GetStructureCandidatesByFormula"
    projects_api$OpenProject(project_id, tomato_project)
    formula_id <- api_instance$GetFormulaCandidates(project_id, aligned_feature_id)[[1]]$formulaId

    response <- api_instance$GetStructureCandidatesByFormula(project_id, aligned_feature_id, formula_id)
    expect_true(inherits(response, "list"))
    expect_true(inherits(response[[1]], "StructureCandidateScored"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetStructureCandidatesByFormulaPaged", {
  # tests for GetStructureCandidatesByFormulaPaged
  # base path: http://localhost:8080
  # Page of CSI:FingerID structure database search candidates for the given &#39;formulaId&#39; with minimal information.
  # Page of CSI:FingerID structure database search candidates for the given &#39;formulaId&#39; with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.
  # @param project_id character project-space to read from.
  # @param aligned_feature_id character feature (aligned over runs) the formula result belongs to.
  # @param formula_id character identifier of the requested formula result
  # @param page integer Zero-based page index (0..N) (optional)
  # @param size integer The size of the page to be returned (optional)
  # @param sort array[character] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. (optional)
  # @param opt_fields array[StructureCandidateOptField] set of optional fields to be included. Use 'none' only to override defaults. (optional)
  # @return [PageStructureCandidateScored]

  tryCatch({

    project_id <- "GetStructureCandidatesByFormulaPaged"
    projects_api$OpenProject(project_id, tomato_project)
    formula_id <- api_instance$GetFormulaCandidates(project_id, aligned_feature_id)[[1]]$formulaId

    response <- api_instance$GetStructureCandidatesByFormulaPaged(project_id, aligned_feature_id, formula_id)
    expect_true(inherits(response, "PagedModelStructureCandidateScored"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})

test_that("GetStructureCandidatesPaged", {
  # tests for GetStructureCandidatesPaged
  # base path: http://localhost:8080
  # Page of structure database search candidates ranked by CSI:FingerID score for the given &#39;alignedFeatureId&#39; with minimal information.
  # Page of structure database search candidates ranked by CSI:FingerID score for the given &#39;alignedFeatureId&#39; with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links.
  # @param project_id character project-space to read from.
  # @param aligned_feature_id character feature (aligned over runs) the structure candidates belong to.
  # @param page integer Zero-based page index (0..N) (optional)
  # @param size integer The size of the page to be returned (optional)
  # @param sort array[character] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. (optional)
  # @param opt_fields array[StructureCandidateOptField] set of optional fields to be included. Use 'none' only to override defaults. (optional)
  # @return [PageStructureCandidateFormula]

  tryCatch({

    project_id <- "GetStructureCandidatesPaged"
    projects_api$OpenProject(project_id, tomato_project)

    response <- api_instance$GetStructureCandidatesPaged(project_id, aligned_feature_id)
    expect_true(inherits(response, "PagedModelStructureCandidateFormula"))

  }, finally = {

    projects_api$CloseProject(project_id)

  })
})